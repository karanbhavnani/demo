#!/usr/bin/python
# ==========================================================================================
# NAME						VERSION 	DESCRIPTION
# Ops_Auto.py				1.0			Python Library for Operations Automation
# ------------------------------------------------------------------------------------------
# AUTHOR					DATE		MODIFICATIONS
# Karan Bhavnani		26 Mar 15	v1.0: First Draft
# ==========================================================================================
# USAGE:
# - Import the library:
# 		from Ops_Auto import *
# - Set the log level (Optional) - default is 1:
# 		import Ops_Auto
#		Ops_Auto.log_level = 0
#		(0 = only errors, 1 = normal, 2 = debug)
# - Functions can be called as below. If the function fails, the return text is set to 'ops_auto_error'.
#		fn_results = executeCommand('ls -l')
#		if fn_results != 'ops_auto_error':
#			print(return_text)
#
# - help('Ops_Auto') will provide details on the functions
# - connection_strings = [<hostname or authtype(http)>,<username>,<password>]
# ==========================================================================================
# Start of Ops Automation Functions
# ------------------------------------------------------------------------------------------
# Default log level
log_level = 1
def logMsg(msg_to_log,msg_type='DEBUG'):
	if msg_to_log == '':
		return 'ops_auto_error'
	import time
	global log_level
	msg_type = msg_type.upper()
	if not(log_level == 0 and msg_type != 'ERROR') and not(log_level == 1 and msg_type == 'DEBUG'):
		formatted_msg = str(time.strftime('%Y-%m-%d %H:%M:%S'))+' - '+str(msg_type.rjust(5))+': '+str(msg_to_log)
		print(formatted_msg)
	return 'OK'
# ------------------------------------------------------------------------------------------
def readArguments(usage_msg):
	varValidate('string','usage_msg',usage_msg)
	import sys
	return_text=sys.argv[1:]
	if return_text == [] or return_text == '':
		logMsg('Usage: '+str(sys.argv[0])+' "'+str(usage_msg)+'"','ERROR')
		return 'ops_auto_error'
	else:
		return_text = ' '.join(return_text)
		return_text = return_text.strip()
		logMsg('Arguments provided: '+str(return_text),'INFO')
		return return_text
# ------------------------------------------------------------------------------------------
def varValidate(variable_type,variable_name,variable_value):
	if variable_type == 'number' and not isinstance(variable_value,int):
		logMsg('Expected number in: '+str(variable_name),'ERROR')
		exit(1)
	elif variable_type == 'string' and not isinstance(variable_value,str):
		logMsg('Expected string in: '+str(variable_name),'ERROR')
		exit(1)
	elif variable_type == 'list' and not isinstance(variable_value,list):
		logMsg('Expected list in: '+str(variable_name),'ERROR')
		exit(1)
	elif variable_type == 'dict' and not isinstance(variable_value,dict):
		logMsg('Expected dictionary in: '+str(variable_name),'ERROR')
		exit(1)
	if (isinstance(variable_value,list) and (variable_value == [] or variable_value == [''])) or variable_value == '':
		logMsg('Found null value in: '+str(variable_name),'ERROR')
		exit(1)
	if variable_name == 'connection_strings':
		local_value = variable_value[:]
		local_value[2] = 'xxxxxxxx'
	else:
		local_value = variable_value
	logMsg(str(variable_name)+' = '+str(local_value))
	return 'OK'
# ------------------------------------------------------------------------------------------
def sendMail(smtpserver,mail_from,mail_to,mail_subject,mail_body):
	logMsg('sendMail(smtpserver,mail_from,mail_to,mail_subject,mail_body)')
	varValidate('string','smtpserver',smtpserver)
	varValidate('string','mail_from',mail_from)
	varValidate('list','mail_to',mail_to)
	varValidate('string','mail_subject',mail_subject)
	varValidate('string','mail_body',mail_body)
	import smtplib
	try:
		mail_content = 'From: '+mail_from+'\nTo: '+str(mail_to)+'\nSubject: '+mail_subject+'\n\n'+mail_body
		mail = smtplib.SMTP(smtpserver)
		mail.sendmail(mail_from,mail_to,mail_content)
		mail.quit()
		logMsg('Mail sent to: '+str(mail_to),'INFO')
		return 'OK'
	except Exception as e:
		logMsg('Send mail failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def httpRequest(http_url,data_values={'NA':'NA'},connection_strings=['NA','NA','NA']):
	logMsg('httpRequest(http_url,data_values={\'NA\':\'NA\'},connection_strings=[\'NA\'])')
	varValidate('string','http_url',http_url)
	varValidate('dict','data_values',data_values)
	varValidate('list','connection_strings',connection_strings)
	import urllib.request
	try:
		return_text = ''
		if connection_strings != ['NA','NA','NA']:
#class urllib.request.HTTPPasswordMgrWithDefaultRealm
# Keep a database of (realm, uri) -> (user, password) mappings. A realm of None is considered a catch-all realm, which is searched if no other realm fits.
			password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()
# HTTPPasswordMgr.add_password(realm, uri, user, passwd)
# uri can be either a single URI, or a sequence of URIs. realm, user and passwd must be strings. This causes (user, passwd) to be used as authentication tokens when authentication for realm and a super-URI of any of the given URIs is given.
			password_mgr.add_password(None,http_url,connection_strings[1],connection_strings[2])
			connection_strings[0] = connection_strings[0].lower()
			if connection_strings[0] == 'basic':
#Handle authentication with the remote host. password_mgr, if given, should be something that is compatible with HTTPPasswordMgr; refer to section HTTPPasswordMgr Objects for information on the interface that must be supported.
				handler = urllib.request.HTTPBasicAuthHandler(password_mgr)
			elif connection_strings[0] == 'digest':
				handler = urllib.request.HTTPDigestAuthHandler(password_mgr)
			else:
				logMsg('Invalid auth method: '+str(connection_strings[0]),'ERROR')
				return 'ops_auto_error'
#build_opener() provides many handlers by default, including a ProxyHandler. By default, ProxyHandler uses the environment variables named <scheme>_proxy, where <scheme> is the URL scheme involved. For example, the http_proxy environment variable is read to obtain the HTTP proxy’s URL.
			opener = urllib.request.build_opener(handler)
			opener.open(http_url)
## ...and install it globally so it can be used with urlopen.
# urllib.request.install_opener(opener)
# urllib.request.urlopen('http://www.example.com/login.html')
			urllib.request.install_opener(opener)
		if data_values != {'NA':'NA'}:
#url should be a string containing a valid URL.
#class urllib.request.Request(url[, data][, headers][, origin_req_host][, unverifiable])
# data may be a string specifying additional data to send to the server, or None if no such data is needed. Currently HTTP requests are the only ones that use data; the HTTP request will be a POST instead of a GET when the data parameter is provided. data should be a buffer in the standard application/x-www-form-urlencoded format. The urllib.parse.urlencode() function takes a mapping or sequence of 2-tuples and returns a string in this format
			data_values_parsed = urllib.parse.urlencode(data_values)
			data_values_parsed = data_values_parsed.encode('utf-8')
			http_request = urllib.request.Request(http_url,data_values_parsed)
		else:
			http_request = urllib.request.Request(http_url)
		http_response = urllib.request.urlopen(http_request)
		return_text = http_response.read()
		if return_text:
			return_text = return_text.decode()
		return_text = return_text.strip()
		logMsg('Content of webpage '+str(http_url)+':\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('HTTP request failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def executeCommand(command_to_execute,cli_options=['NA']):
	logMsg('executeCommand(command_to_execute)')
	varValidate('string','command_to_execute',command_to_execute)
	varValidate('list','cli_options',cli_options)
	import subprocess, time
	try:
		return_text = ''
#The subprocess module allows you to spawn new processes, connect to their input/output/error pipes, and obtain their return codes Execute a child program in a new process
		sub = subprocess.Popen(command_to_execute,stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True,universal_newlines=True)
		if cli_options != ['NA']:
			for cli_option in cli_options:
				logMsg('Entering option: '+str(cli_option))
				sub.stdin.write(str(cli_option)+'\n')
# Python's standard out is buffered (meaning that it collects some of the data "written" to standard out before it writes it to the terminal). Calling sys.stdout.flush() forces it to "flush" the buffer, meaning that it will write everything in the buffer to the terminal, even if normally it would wait before doing so.
				sub.stdin.flush()
				time.sleep(1)
# Popen.communicate(input=None, timeout=None)
# Interact with process: Send data to stdin. Read data from stdout and stderr, until end-of-file is reached. Wait for process to terminate. The optional input argument should be data to be sent to the child process, or None, if no data should be sent to the child. The type of input must be bytes or, if universal_newlines was True, a string.

# communicate() returns a tuple (stdout_data, stderr_data). The data will be bytes or, if universal_newlines was True, strings.

# Note that if you want to send data to the process’s stdin, you need to create the Popen object with stdin=PIPE. Similarly, to get anything other than None in the result tuple, you need to give stdout=PIPE and/or stderr=PIPE too.

# If the process does not terminate after timeout seconds, a TimeoutExpired exception will be raised. Catching this exception and retrying communication will not lose any output.

# The child process is not killed if the timeout expires, so in order to cleanup properly a well-behaved application should kill the child process and finish communication:
		sub_out, sub_err = sub.communicate()
		if sub_err:
			logMsg('Popen execution failed:\n'+str(sub_err),'ERROR')
			return 'ops_auto_error'
		return_text = str(sub_out)
		return_text = return_text.strip()
		
		logMsg('Output of '+str(command_to_execute)+':\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Command execution failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def executeSSH(command_to_execute,connection_strings):
	logMsg('executeSSH(command_to_execute,connection_strings)')
	varValidate('string','command_to_execute',command_to_execute)
	varValidate('list','connection_strings',connection_strings)
	import paramiko
	try:
		return_text = ''
		ssh = paramiko.SSHClient()
		# ssh = paramiko.SSHClient()
        # ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        # ssh.connect(host, port=22, username='dummy', password='dummy')
        # print "Connected to %s" % host
        # break
		ssh.set_missing_host_key_policy(paramiko.WarningPolicy())
		ssh.connect(connection_strings[0],username=connection_strings[1],password=connection_strings[2])
		ssh_in, ssh_out, ssh_err = ssh.exec_command(command_to_execute)
		ssh_errs = ssh_err.readlines()
		ssh_err_lines = ''.join(err_line for err_line in ssh_errs)
		if ssh_err_lines:
			logMsg('SSH execution failed:\n'+str(ssh_err_lines),'ERROR')
			return 'ops_auto_error'
		ssh_outs = ssh_out.readlines()
		return_text = ''.join(out_line for out_line in ssh_outs)
		ssh.close()
		return_text = return_text.strip()
		logMsg('Output of '+str(command_to_execute)+' on '+str(connection_strings[0])+':\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('SSH failed!\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def executeSSHS(commands_to_execute,connection_strings):
          logMsg('executeSSHS(commands_to_execute,connection_strings)')
          varValidate('list','commands_to_execute',commands_to_execute)
          varValidate('list','connection_strings',connection_strings)
          import paramiko
          try:
                   ssh_outputs = []
                   ssh = paramiko.SSHClient()
                   ssh.set_missing_host_key_policy(paramiko.WarningPolicy())
                   ssh.connect(connection_strings[0],username=connection_strings[1],password=connection_strings[2])
                   i = 0
                   while i < len(commands_to_execute):
                             ssh_in, ssh_out, ssh_err = ssh.exec_command(commands_to_execute[i])
                             ssh_errs = ssh_err.readlines()
                             ssh_err_lines = ''.join(err_line for err_line in ssh_errs)
                             if ssh_err_lines:
                                      logMsg('Command failed: '+str(commands_to_execute[i])+'\n'+str(ssh_err_lines),'ERROR')
                                      ssh_output.append('ops_auto_error')
                             else:
                                      ssh_outs = ssh_out.readlines()
                                      ssh_out_lines = ''.join(out_line for out_line in ssh_outs)
                                      if ssh_out_lines:
                                                ssh_outputs.append(ssh_out_lines)
                                      else:
                                                ssh_outputs.append('NA')
                             i = i + 1
                   ssh.close()
                   logMsg('Output of '+str(commands_to_execute)+' on '+str(connection_strings[0])+':\n'+str(ssh_outputs),'INFO')
                   return ssh_outputs
          except Exception as e:
                   logMsg('SSH failed!\n'+str(e),'ERROR')
                   return 'ops_auto_error'
# ------------------------------------------------------------------------------------------

def executeSQL(db_type,sql_to_execute,db_name,connection_strings=['NA','NA','NA']):
	logMsg('executeSQL(db_type,sql_to_execute,db_name,connection_strings=[\'NA\'])')
	varValidate('string','db_type',db_type)
	varValidate('string','sql_to_execute',sql_to_execute)
	varValidate('string','db_name',db_name)
	varValidate('list','connection_strings',connection_strings)
	try:
		return_text = ''
		db_type = db_type.lower()
		if db_type == 'mysql':
			import MySQLdb
			db = MySQLdb.connect(host=connection_strings[0],user=connection_strings[1],password=connection_strings[2],database=db_name)
		elif db_type == 'sybase':
			import sybpydb
			db = sybpydb.connect(host=connection_strings[0],user=connection_strings[1],password=connection_strings[2],database=db_name)
		elif db_type == 'oracle':
			import cx_Oracle
			db = cx_Oracle.connect(connection_strings[1],connection_strings[2],db_name)
		elif db_type == 'msaccess':
			import pypyodbc
			db = pypyodbc.connect('DRIVER={Microsoft Access Driver (*.mdb)};DBQ='+db_name)
		else:
			logMsg('Invalid DB type: '+str(db_type),'ERROR')
			return 'ops_auto_error'
# a database cursor is a control structure that enables traversal over the records in a database.
# you can see that a python module cursor is needed even for a 'create table' statement, so it's used for cases where a mere connection object should suffice - as correctly pointed out by the OP. Such abstraction is different from what people understand a db cursor to be, and hence the confusion/frustration on the part of users. Regardless of efficiency, it's just a conceptual overhead. Would be nice if it was pointed out in the docs that the python module cursor is bit different than what a cursor is in SQL and databases.
# Once you have a Connection, you can create a Cursor object and call its execute() method to perform SQL commands
		db_cursor = db.cursor()
		db_cursor.execute(sql_to_execute)
# you can either treat the cursor as an iterator, call the cursor’s fetchone() method to retrieve a single matching row, or call fetchall() to get a list of the matching rows.
		sql_output = db_cursor.fetchall()
		if sql_output:
			return_text = '\n'.join(str(line_in_sql).lstrip('(').rstrip(')') for line_in_sql in sql_output if line_in_sql)
		db.close()
		return_text = return_text.strip()
		logMsg('Output of '+str(sql_to_execute)+' on '+str(db_name)+':\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('SQL execution failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def readFile(source_file_path):
	logMsg('readFile(source_file_path)')
	varValidate('string','source_file_path',source_file_path)
	import os
	try:
		return_text = ''
		if os.path.exists(source_file_path):
			file = open(source_file_path,'r')
			return_text = file.read()
			file.close()
		else:
			logMsg('Invalid path: '+str(source_file_path),'ERROR')
			return 'ops_auto_error'
		return_text = return_text.strip()
		logMsg('Content of '+str(source_file_path)+':\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Read file failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def zipFiles(source_dir,source_files,target_dir,target_file):
	logMsg('zipFiles(source_dir,source_files,target_dir,target_file)')
	varValidate('string','source_dir',source_dir)
	varValidate('list','source_files',source_files)
	varValidate('string','target_dir',target_dir)
	varValidate('string','target_file',target_file)
# This module provides tools to create, read, write, append, and list a ZIP file.
# This module provides a portable way of using operating system dependent functionality
	import os, zipfile
	try:
		return_text = ''
		target_file_path = os.path.join(target_dir,target_file)
		if os.path.exists(target_file_path):
			os.remove(target_file_path)
			logMsg('Existing file removed: '+str(target_file_path),'WARN')
		zf = zipfile.ZipFile(target_file_path,'a')
		for source_file in source_files:
			if source_file:
				source_file_path = os.path.join(source_dir,source_file)
				if os.path.exists(source_file_path):
					zf.write(source_file_path,source_file)
				else:
					logMsg('Invalid path: '+str(source_file_path),'ERROR')
					return 'ops_auto_error'
		return_text = '\n'.join(os.listdir(target_dir))
		zf.close()
		return_text = return_text.strip()
		logMsg('Dir list, after Zip:\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Zip files failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def ftpFiles(ftp_type,local_dir,ftp_files,connection_strings,remote_dir='NA'):
	logMsg('ftpFiles(ftp_type,local_dir,ftp_files,connection_strings,remote_dir=\'NA\')')
	varValidate('string','ftp_type',ftp_type)
	varValidate('string','local_dir',local_dir)
	varValidate('list','ftp_files',ftp_files)
	varValidate('list','connection_strings',connection_strings)
	varValidate('string','remote_dir',remote_dir)
	import os, ftplib
	try:
		return_text = ''
		ftp_type = ftp_type.upper()
# class ftplib.FTP([host[, user[, passwd[, acct[, timeout]]]]])
# Return a new instance of the FTP class. When host is given, the method call connect(host) is made. When user is given, additionally the method call login(user, passwd, acct) is made (where passwd and acct default to the empty string when not given).
# >>> from ftplib import FTP
# >>> ftp = FTP('ftp.debian.org')     # connect to host, default port
# >>> ftp.login()                     # user anonymous, passwd anonymous@
# '230 Login successful.'
# >>> ftp.cwd('debian')               # change into "debian" directory
# >>> ftp.retrlines('LIST')           # list directory contents
# -rw-rw-r--    1 1176     1176         1063 Jun 15 10:18 README
# ...
# drwxr-sr-x    5 1176     1176         4096 Dec 19  2000 pool
# drwxr-sr-x    4 1176     1176         4096 Nov 17  2008 project
# drwxr-xr-x    3 1176     1176         4096 Oct 10  2012 tools
# '226 Directory send OK.'
# >>> ftp.retrbinary('RETR README', open('README', 'wb').write)
# '226 Transfer complete.'
# >>> ftp.quit()
		ftp = ftplib.FTP(connection_strings[0],connection_strings[1],connection_strings[2])
		if remote_dir != 'NA':
			ftp.cwd(remote_dir)
		if ftp_type == 'RETR': # Download
			for ftp_file in ftp_files:
				if ftp_file and os.path.isdir(local_dir):
					ftp.retrbinary('RETR '+str(ftp_file),open(os.path.join(local_dir,ftp_file),'wb').write)
				else:
					logMsg('Invalid path: '+str(local_dir),'ERROR')
					return 'ops_auto_error'
			return_text = '\n'.join(os.listdir(local_dir))
		elif ftp_type == 'STOR': # Upload
			for ftp_file in ftp_files:
				if ftp_file:
					ftp_file_path = os.path.join(local_dir,ftp_file)
					if os.path.exists(ftp_file_path):
						ftp.storbinary('STOR '+str(ftp_file),open(ftp_file_path,'rb'))
					else:
						logMsg('Invalid path: '+str(ftp_file_path),'ERROR')
						return 'ops_auto_error'
			return_text = '\n'.join(ftp.retrlines('LIST'))
		else:
			logMsg('Invalid FTP type: '+str(ftp_type),'ERROR')
			return 'ops_auto_error'
		ftp.quit()
		return_text = return_text.strip()
		logMsg('Dir list, after FTP:\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('FTP files failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def archiveFiles(source_dir,older_than_days):
	logMsg('archiveFiles(source_dir,older_than_days)')
	varValidate('string','source_dir',source_dir)
	varValidate('number','older_than_days',older_than_days)
	import os, datetime
	try:
		return_text = ''
		today = datetime.datetime.now()
		if os.path.isdir(source_dir):
			for dirpath, dirnames, filenames in os.walk(source_dir):
				for filename in filenames:
					file_full_path = os.path.join(dirpath,filename)
					file_modified = datetime.datetime.fromtimestamp(os.path.getmtime(file_full_path))
					if today - file_modified > datetime.timedelta(days=older_than_days):
						os.remove(file_full_path)
						logMsg('File removed: '+str(filename),'INFO')
			return_text = '\n'.join(os.listdir(source_dir))
		else:
			logMsg('Invalid path: '+str(source_dir),'ERROR')
			return 'ops_auto_error'
		return_text = return_text.strip()
		logMsg('Dir list, after archive:\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Archive files failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'

# ------------------------------------------------------------------------------------------
def fileInfo(source_file_path,time_format='%Y-%m-%d %H:%M:%S'):
	logMsg('fileInfo(source_file_path,time_format=\'%Y-%m-%d %H:%M:%S\')')
	varValidate('string','source_file_path',source_file_path)
	varValidate('string','time_format',time_format)
	import os, datetime
	try:
		return_text = ''
		if os.path.exists(source_file_path):
			file_stats = os.stat(source_file_path)
# st_mode - protection bits,
# st_ino - inode number,
# st_dev - device,
# st_nlink - number of hard links,
# st_uid - user id of owner,
# st_gid - group id of owner,
# st_size - size of file, in bytes,
# st_atime - time of most recent access,
# st_mtime - time of most recent content modification,
# st_ctime - platform dependent; time of most recent metadata change on Unix, or the time of creation on Windows)
			if file_stats:
				file_mtime = datetime.datetime.fromtimestamp(file_stats.st_mtime)
				file_mtime = file_mtime.strftime(time_format)
				return_text = str(file_mtime)+' '+str(file_stats.st_size)
			else:
				logMsg('Stats failed: '+str(source_file),'ERROR')
		else:
			logMsg('Invalid path: '+str(source_file_path),'ERROR')
			return 'ops_auto_error'
		return_text = return_text.strip()
		logMsg('Info of '+str(source_file_path)+':\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('File info failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def formatText(input_text,chars_to_remove=['NA']):
	logMsg('formatText(input_text,chars_to_remove=[\'NA\'])')
	varValidate('string','input_text',input_text)
	varValidate('list','chars_to_remove',chars_to_remove)
	import re
	try:
		return_text = ''
		return_text = re.sub('[ \t]+',' ',input_text)
		return_text = re.sub('\n+','\n',return_text)
		if chars_to_remove != ['NA']:
			for char_to_remove in chars_to_remove:
				if char_to_remove:
					return_text = return_text.replace(char_to_remove,'')
# .strip() removes all whitespace at the start and end, including spaces, tabs, newlines and carriage returns.
		return_text = return_text.strip()
		logMsg('Formatted text:\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Format text failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def findPatterns(input_text,patterns_to_find,starts_with_pattern='no'):
	logMsg('findPatterns(input_text,patterns_to_find,starts_with_pattern=\'no\')')
	varValidate('string','input_text',input_text)
	varValidate('list','patterns_to_find',patterns_to_find)
	varValidate('string','starts_with_pattern',starts_with_pattern)
	try:
		return_text = ''
		# splitlines() method is designed to split each line into a list element.
		# str.startswith allows you to supply a tuple of strings to test for:
	# if link.lower().startswith(("js", "catalog", "script", "katalog")):
		lines_in_text = input_text.splitlines()
		for pattern_to_find in patterns_to_find:
			if pattern_to_find:
				for line_in_text in lines_in_text:
					if line_in_text:
						line_in_text = line_in_text.strip()
						if (starts_with_pattern == 'no' and pattern_to_find in line_in_text) or (starts_with_pattern != 'no' and line_in_text.startswith(pattern_to_find)):
							return_text = return_text+str(line_in_text)+'\n'
		return_text = return_text.strip()
		logMsg('Lines with '+str(patterns_to_find)+':\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Find pattern failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def removePatterns(input_text,patterns_to_remove,starts_with_pattern='no'):
	logMsg('removePatterns(input_text,patterns_to_remove,starts_with_pattern=\'no\')')
	varValidate('string','input_text',input_text)
	varValidate('list','patterns_to_remove',patterns_to_remove)
	varValidate('string','starts_with_pattern',starts_with_pattern)
	try:
		return_text = input_text
		for pattern_to_remove in patterns_to_remove:
			if pattern_to_remove:
				lines_in_text = return_text.splitlines()
				return_text = ''
				for line_in_text in lines_in_text:
					if line_in_text:
						line_in_text = line_in_text.strip()
						if (starts_with_pattern == 'no' and pattern_to_remove not in line_in_text) or (starts_with_pattern != 'no' and not line_in_text.startswith(pattern_to_remove)):
							return_text = return_text+str(line_in_text)+'\n'
		return_text = return_text.strip()
		logMsg('Lines without '+str(patterns_to_remove)+':\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Remove pattern failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def countUnique(input_text):
	logMsg('countUnique(input_text)')
	varValidate('string','input_text',input_text)
	import operator
	try:
		return_text = ''
		lines_in_text = input_text.splitlines()
		unique_dict = {}
		for line_in_text in lines_in_text:
			if line_in_text:
				line_in_text = line_in_text.strip()
				if line_in_text in unique_dict:
					unique_dict[line_in_text] += 1
				else:
					unique_dict[line_in_text] = 1
		if unique_dict:
			logMsg('After adding to dict: '+str(unique_dict))
			sorted_dict = sorted(unique_dict.items(),key=operator.itemgetter(1))
			return_text = '\n'.join('{}: {}'.format(val,key) for key,val in sorted_dict)
		return_text = return_text.strip()
		logMsg('Count unique:\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Count unique failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def sortColumns(input_text,column_number,reverse_order='no'):
	logMsg('sortColumns(input_text,column_number)')
	varValidate('string','input_text',input_text)
	varValidate('number','column_number',column_number)
	varValidate('string','reverse_order',reverse_order)
	import operator
	try:
		return_text = ''
		lines_in_text = input_text.splitlines()
		lines_dict = []
		for line_in_text in lines_in_text:
			if line_in_text:
				line_in_text = line_in_text.strip()
				words_in_text = line_in_text.split(' ')
				i = 0
				for word_in_text in words_in_text:
					if word_in_text.isdigit():
						words_in_text[i] = word_in_text.rjust(16,'0')
					i = i + 1
				if words_in_text and column_number < len(words_in_text):
					lines_dict.append(words_in_text)
				else:
					logMsg('Column num '+str(column_number)+' out of boundary in: '+str(words_in_text),'WARN')
		if lines_dict:
			logMsg('After adding to dict: '+str(lines_dict))
			if reverse_order == 'no':
				sorted_dict = sorted(lines_dict,key=operator.itemgetter(column_number))
			else:
				sorted_dict = sorted(lines_dict,key=operator.itemgetter(column_number),reverse=True)
			for line_in_dict in sorted_dict:
				i = 0
				for word_in_dict in line_in_dict:
					if word_in_dict.isdigit():
						line_in_dict[i] = word_in_dict.lstrip('0')
					i = i + 1
				return_text = return_text+' '.join(line_in_dict)+'\n'
		return_text = return_text.strip()
		logMsg('Sorted on column '+str(column_number)+':\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Sort columns failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def stringBetween(input_text,preceding_string,succeeding_string):
	logMsg('stringBetween(input_text,preceding_string,succeeding_string)')
	varValidate('string','input_text',input_text)
	varValidate('string','preceding_string',preceding_string)
	varValidate('string','succeeding_string',succeeding_string)
	import re
	try:
		return_text = ''
		input_text = input_text.replace('\n','nxtln')
		return_texts = re.search(preceding_string+'(.*)'+succeeding_string,input_text)
		if return_texts:
			return_text = return_texts.group(1)
			return_text = return_text.replace('nxtln','\n')
		return_text = return_text.strip()
		logMsg('String between '+str(preceding_string)+' and '+str(succeeding_string)+':\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Split failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def getColumns(input_text,column_numbers,delimiter='NA'):
	logMsg('getColumns(input_text,column_numbers,delimiter=\'NA\')')
	varValidate('string','input_text',input_text)
	varValidate('list','column_numbers',column_numbers)
	varValidate('string','delimiter',delimiter)
	try:
		return_text = ''
		lines_in_text = input_text.splitlines()
		for line_in_text in lines_in_text:
			if line_in_text:
				line_in_text = line_in_text.strip()
				if delimiter == 'NA':
					words_in_text = list(line_in_text)
				else:
					words_in_text = line_in_text.split(delimiter)
				if words_in_text:
					logMsg('After delimiting: '+str(words_in_text))
					column_text = ''
					for column_number in column_numbers:
						if column_number != '' and column_number < len(words_in_text):
							column_text = column_text+words_in_text[column_number]+' '
						else:
							logMsg('Column num '+str(column_number)+' out of boundary in: '+str(words_in_text),'WARN')
					return_text = return_text+str(column_text)+'\n'
		return_text = return_text.strip()
		logMsg('Columns '+str(column_numbers)+':\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Get columns failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def getRows(input_text,from_line,to_line=0):
	logMsg('getRows(input_text,from_line,to_line=0)')
	varValidate('string','input_text',input_text)
	varValidate('number','from_line',from_line)
	varValidate('number','to_line',to_line)
	try:
		return_text = ''
		lines_in_text = input_text.splitlines()
		if to_line == 0:
			return_text = lines_in_text[from_line:]
		else:
			return_text = lines_in_text[from_line:to_line]
		return_text = '\n'.join(return_text)
		return_text = return_text.strip()
		logMsg('Rows '+str(from_line)+' to '+str(to_line)+':\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Get rows failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def compareText(file1_text,file2_text,sort_lines='no'):
	logMsg('compareText(file1_text,file2_text,sort_lines=\'no\')')
	varValidate('string','file1_text',file1_text)
	varValidate('string','file2_text',file2_text)
	varValidate('string','sort_lines',sort_lines)
	import os, difflib
# The default output produced by Differ is similar to the diff command line tool is simple with the Differ class. It includes the original input values from both lists, including common values, and markup data to indicate what changes were made.

# Lines prefixed with - indicate that they were in the first sequence, but not the second.
# Lines prefixed with + were in the second sequence, but not the first.
# If a line has an incremental difference between versions, an extra line prefixed with ? is used to highlight the change within the new version.
# If a line has not changed, it is printed with an extra blank space on the left column so that it it lines up with the other lines that may have differences.
# To compare text, break it up into a sequence of individual lines and pass the sequences to compare().

# import difflib
# from difflib_data import *

# d = difflib.Differ()
# diff = d.compare(text1_lines, text2_lines)
# print '\n'.join(diff)
	try:
		return_text = ''
		file1_lines = file1_text.splitlines()
		file2_lines = file2_text.splitlines()
		if sort_lines != 'no':
			file1_lines.sort()
			file2_lines.sort()
		diff_instance = difflib.Differ()
		diff_lines = list(diff_instance.compare(file1_lines,file2_lines))
		if diff_lines:
			return_text = '\n'.join(diff_line for diff_line in diff_lines if diff_line[0] == '-' or diff_line[0] == '+')
			return_text = return_text.replace('\n\n','\n')
		return_text = return_text.strip()
		logMsg('Difference between the 2 texts:\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Compare files failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
def addMinutes(date_string,minutes_to_add,time_format='%Y-%m-%d %H:%M:%S'):
	logMsg('addMinutes(date_string,minutes_to_add,time_format=\'%Y-%m-%d %H:%M:%S\')')
	varValidate('string','date_string',date_string)
	varValidate('number','minutes_to_add',minutes_to_add)
	varValidate('string','time_format',time_format)
	import datetime
	try:
		return_text = ''
		input_datetime = datetime.datetime.strptime(date_string,time_format)
		if input_datetime:
			return_text = input_datetime + datetime.timedelta(minutes=minutes_to_add)
			return_text = return_text.strftime(time_format)
		return_text = return_text.strip()
		logMsg('Datetime after adding '+str(minutes_to_add)+':\n'+str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Add time failed:\n'+str(e),'ERROR')
		return 'ops_auto_error'
# ------------------------------------------------------------------------------------------
#Sumit Chawla 20-April-2015
#Modules imported
import uuid, hashlib
# ------------------------------------------------------------------------------------------
# module to get encrypted string
def hashString(string_to_hash):
    salt = uuid.uuid4().hex
    return hashlib.sha256(salt.encode() + string_to_hash.encode()).hexdigest() + ':' + salt 
def checkString(hashed_string,user_string):
    new_str,salt = hashed_string.split(':')
    return new_str == hashlib.sha256(salt.encode() + user_string.encode()).hexdigest()
# ------------------------------------------------------------------------------------------
# End of Ops_Auto
# ==========================================================================================
# os.rename(source_file_path,target_file_path)
# os.remove(source_file_path)
# os.rmdir(source_dir)
# shutil.move(source_file_path,target_file_path)
# shutil.rmtree(source_dir)
# os.mkdir(target_dir)
# $(Get-Item file.txt).lastwritetime=$(Get-Date "30/03/2015 01:00 am")
# re.sub('[^A-Za-z0-9]+','',input_text)
# datetime.datetime.today().strftime(time_format)
# datetime.datetime.strptime(date_string,time_format)
# ------------------------------------------------------------------------------------------
