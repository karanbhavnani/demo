
Python GET COOKIE VALUE

#!/gns/mw/lang/python/python-2.7.2-gns.03/bin/python
import urllib2,urllib,getpass,cookielib
import sys
sys.path.append('/gns/mw/lang/python/modules/2.7.2/requests-2.6.0/lib/python2.7/site-packages')
username = raw_input("Enter kerberos ID: ")
password = getpass.getpass("Enter password: ")
GSSSO = ""
REFERER="http://home.gs.com"
WEBID_AUTH_URL = "https://webid.is.gs.com/cgi-bin/V4/authenticate.cgi"
params = {"referpg": REFERER.encode("base64").strip(), "username": username,
  "password": password}
headers = {"Referer": REFERER}
jar = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(jar))
req = urllib2.Request(WEBID_AUTH_URL, urllib.urlencode(params),
  headers, REFERER)
opener.open(req).close()
for cookie in jar:
  if "GSSSO" in cookie.name:
    GSSSO = "GSSSO="+cookie.value
    break
print GSSSO



ICONCLUDE REST AUTOMATED TESTING

#!/usr/bin/perl

use strict;

use HTTP::Headers;
# class implementing a web user agent. LWP::UserAgent objects can be used to dispatch web requests
# In normal use the application creates an LWP::UserAgent object, and then configures it with values for timeouts, proxies, name, etc. It then creates an instance of HTTP::Request for the request that needs to be performed. This request is then passed to one of the request method the UserAgent, which dispatches it using the relevant protocol, and returns a HTTP::Response object. There are convenience methods for sending the most common request types: get(), head(), post(), put() and delete(). When using these methods then the creation of the request object is hidden as shown in the synopsis above.

use LWP::UserAgent;

use Data::Dumper;


use constant ICONCLUDE_DEV_URL => "https://central2.dual.dev.iconclude.services.gs.com:8443";
use constant ICONCLUDE_SERVICES_PATH => "/PAS/services/http/execute";
use constant ALERTS_ALL_FLOW_PATH => "/Library/GS%20Flows/Network/SANK/Alerts/Alerts.All/Alerts.All";

my $iteration = 1;
#my $inputLine = $_;
my $filename = '//home//bhavnk//testcases.txt';
open(my $fh, '<:encoding(UTF-8)', $filename)
or die "Could not open file '$filename' $!";

while (my $row = <$fh>) {
						chomp $row;
						
						$filename =~ s/^\s+|\s+$//g;

						my ($hostName, $alertText) = split(/\s/, $row, 2);


						if($hostName ne "" and $alertText ne "")
							{
								printTestStart($iteration, "nco_node = $hostName , nco_summary = $alertText");
								my $flowUrl = ICONCLUDE_DEV_URL.ICONCLUDE_SERVICES_PATH.ALERTS_ALL_FLOW_PATH;
								my %params = ("nco_node" => $hostName, "nco_summary" => $alertText);

								my $iConcludeResponse = callIConcludeFlow($flowUrl, \%params);

								my $errorsFound = validateResponse($iConcludeResponse);

								print "\nResponse:\n$iConcludeResponse\n\nErrors Found in Test :$errorsFound";
							}

						$iteration++;
						}			


sub validateResponse{
  my ($iConcludeResponse) = @_;
  
  if(!($iConcludeResponse =~ /Command Script \d* completed successfully/i))
  {
    return "Error Found";
  }
  return "Success";
}


sub printTestStart(){
                my ($number,$params) = @_;
                
                print "\n\n##################################################################################################\n\n";
                print "Starting Test $number\n";
                print "Calling Flow : ".ALERTS_ALL_FLOW_PATH."\n";
                print "With Parameters : $params\n";
}

sub callIConcludeFlow{
                my ($url, $params) = @_;
                my $iConcludeReturn = doPostCall($url, $params);
                my $data = $iConcludeReturn;
                $data =~ m/<flow-result>(.*)<\/flow-result>/is;
                $data = $1;
                return $data;
}



sub doPostCall{
                my ($url, $params) = @_;
                my $browser = LWP::UserAgent->new;
                my $header = HTTP::Headers->new;
                $header->authorization_basic('bhavnk','Infy_12345'); 
                $browser->default_headers($header);
                
                my $response=$browser->post($url, $params);                
                
                return $response->content();
}


POWERSHELL 

#	1.	PowerShell command to use  Putty to connect to the dc host where the script resides and pass test cases as arguments

$arglist= "-ssh bhavnk@d161432-001.dc.gs.com -pw Infy_12345 -m Z:\bhavnk\runperl.txt" 
$putty_connect = start-process -filepath "C:\Program Files (x86)\Portable PuTTY\plink.exe" -ArgumentList $arglist -PassThru -wait -Nonewwindow -RedirectStandardOutput Z:\bhavnk\new.doc
$sr_no_list	= 0;
$errorex = 'Errors Found'
$Path = 'Z:\bhavnk\'
$i=0;




#	2. PowerShell script to write to an excel sheet

Get-ChildItem $Path -Filter *.doc -Recurse| 
   Where-Object { $_.Attributes -ne "Directory"} | 
      ForEach-Object{ 
						$nco_list +=  (Get-Content $_.FullName | findstr 'nco_node  '| Select-String -Pattern '\S*\.gs.com' |% { $_.Matches }  | % { $_.Value })
						$nco_summary_list	+= (Get-Content $_.FullName | findstr 'nco_summary  '|Select-String -Pattern 'nco_summary.*' |% { $_.Matches }  | % { $_.Value })
						$error_list += (Get-Content "Z:\bhavnk\new.doc" | Select-String -Pattern 'Errors Found in Test :\S*'| % { $_.Matches }  | % { $_.Value })
					}	

					
$results_list=@()
$new_list=@()
$result= Get-Content "Z:\bhavnk\new.txt"

# for($i=0;$i -lt $b.Count;$i++)
# {
	# $b+=$result.IndexOf|findstr "Response"
	# $b
	# $c+=$result..IndexOf|findstr "FailureMessage=;TimedOut=;Result=;}"
	# $c
	# #$x=$result.IndexOf($b[$i])
	# #$y=$result.IndexOf($c[$i])
	# $results_list += $result[$b[$i]..$c[$i]]
	# #$results_list += $results_list1 -join("`n")
	
# }



#	3.	Module to open Excel  and add worksheets

$excel_app = New-Object -Com Excel.Application
$excel_app.visible = $True
$excel = $excel_app.Workbooks.Add()

#	4.	Creating an array which consists of the column names in Automated Testing sheet:-


$sheet4 = $excel.WorkSheets.Item(1)
$sheet4.name = "Automated Testing"
$sheet4_col=@("TEST SR-NO","HOST","ALERT STRING","RESPONSE","RESULTS")
$count=$sheet4_col.length
for ($n=1; $n -le $count ; $n++)
{				
				$sheet4.Cells.Item(1,$n).HorizontalAlignment = -4108
                $sheet4.Cells.Item(1,$n) = $sheet4_col[($n-1)]

}

$workBook = $sheet4.UsedRange
$workBook.Interior.ColorIndex = 5
$workBook.Font.ColorIndex = 2
$workBook.Font.Bold = $True
$intRow4 = 2
$count1 = $nco_list.length

#	5.	Writing to each row of the excel sheet

 for ($n=1; $n -le $count1 ; $n++)
 {	

		$sr_no_list = $sr_no_list + 1
		$sheet4.Cells.Item($intRow4,1) = $sr_no_list
        $sheet4.Cells.Item($intRow4,2) = $nco_list[($n-1)]
		$sheet4.Cells.Item($intRow4,3) = $nco_summary_list[($n-1)]
		$sheet4.Cells.Item($intRow4,4) = $error_list[($n-1)]
		$sheet4.Cells.Item($intRow4,5) = $results_list[($n-1)]
		
		$sheet4.Cells.Item($intRow4,1).HorizontalAlignment = -4108
		#$sheet4.Cells.Item($intRow4,2).HorizontalAlignment = -4108
		$sheet4.Cells.Item($intRow4,3).HorizontalAlignment = -4108
		$sheet4.Cells.Item($intRow4,4).HorizontalAlignment = -4108
		#$sheet4.Cells.Item($intRow4,5).HorizontalAlignment = -4108
		
		$intRow4 = $intRow4 + 1
		$sheet4.columns.autofit()
 }

SOAP REQUEST

#!/gns/mw/lang/python/python-2.7.2-gns.03/bin/python
import getpass,sys,os

# Idea is username, password, request xml, and the values required for the xml  will be passed as arguments to the script via iConclude
# and as in a soap call we do request by passing an xml and response is also generated in xml format; thats why we are passing xml template to soapRequester function 
# url variable contains the value of url to which this xml need to be passed
log_level = 2
script_home = "/home/"+str(os.getlogin())+"/"
logfile = script_home+"web_service.log"
#sample url
url = "http://esm-star.csnetwork.services.gs.com:7070/STARWeb/services/STARWS"
op = ''#output
script_name = str(sys.argv[0])
username = raw_input("Enter kerberos ID: ")
#getpass module is required to ask for password in hidden format
password = getpass.getpass("Enter password: ")
#data required for example xml
ticketNo="SR5294109"
#example xml
xml_data="""<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:sch="http://www.star.fw.gs.com/svcrecord/schemas">
<soapenv:Header/>
<soapenv:Body>
  <sch:QueryTicketRequest>
	 <sch:ServiceRecordNumber>"""+str(ticketNo.strip())+"""</sch:ServiceRecordNumber>
  </sch:QueryTicketRequest>
</soapenv:Body>
</soapenv:Envelope>
		"""
#============================================================================================
# Function to validate the variables
#============================================================================================
def varValidate(variable_type,variable_name,variable_value):
        if variable_type == 'number' and not isinstance(variable_value,int):
                logMsg('Expected number in: '+str(variable_name),'ERROR')
                exit(1)
        elif variable_type == 'string' and not isinstance(variable_value,str):
		logMsg('Expected string in: '+str(variable_name),'ERROR')
                exit(1)
        elif variable_type == 'list' and not isinstance(variable_value,list):
                logMsg('Expected list in: '+str(variable_name),'ERROR')
                exit(1)
        elif variable_type == 'dict' and not isinstance(variable_value,dict):
                logMsg('Expected dictionary in: '+str(variable_name),'ERROR')
                exit(1)
        if (isinstance(variable_value,list) and (variable_value == [] or variable_value == [''])) or variable_value == '':
                logMsg('Found null value in: '+str(variable_name),'ERROR')
                exit(1)
        if variable_name == 'connection_strings':
                local_value = variable_value[:]
                local_value[2] = 'xxxxxxxx'
        else:
                local_value = variable_value
        logMsg(str(variable_name)+' = '+str(local_value))
        return 'OK'
#============================================================================================
# Function to write messages to log files
#============================================================================================
def logMsg(msg_to_log,msg_type='DEBUG'):
	if msg_to_log == '':
		return 'ops_auto_error'
	import time
	global log_level
	msg_type = msg_type.upper()
	if not(log_level == 0 and msg_type != 'ERROR') and not(log_level == 1 and msg_type == 'DEBUG'):
		formatted_msg = str(time.strftime('%Y-%m-%d %H:%M:%S'))+' - '+str(msg_type.rjust(5))+': '+str(msg_to_log)
		f=open(logfile,"a")
    	        f.write(formatted_msg+"\n")
                f.close()
        return 'OK'
#============================================================================================
# Function to call Any SOAP URL
#============================================================================================
def soapRequester(xml_template,username,password,url):
	logMsg('soapRequester(xml_template,username,password,url)','DEBUG')
	varValidate('string','xml_template',xml_template)
	varValidate('string','username',username)
	#Not validating Password otherwise it will be saved in log file
	varValidate('string','url',url)
	try:
		import urllib2,urllib,cookielib
		import sys,HTMLParser
		GSSSO = ""
		REFERER="http://home.gs.com"
		WEBID_AUTH_URL = "https://webid.is.gs.com/cgi-bin/V4/authenticate.cgi"
		params = {"referpg": REFERER.encode("base64").strip(), "username": username,
		  "password": password}
		headers = {"Referer": REFERER}
		jar = cookielib.CookieJar()
		opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(jar))
		req = urllib2.Request(WEBID_AUTH_URL, urllib.urlencode(params),
		  headers, REFERER)
		resp=opener.open(req).close()
		header = {'content-type': 'text/xml','charset':'utf-8'}
		request = urllib2.Request(url,data=xml_template,headers=header)
		response = opener.open(request)
		result=response.read()
		logMsg('Raw Result obtained after calling web service\n '+str(result),'INFO')
		# result is parsed to unescape &lt to < symbol, &gt to > symbol , &amp to & and likewise
		parsed_result=HTMLParser.HTMLParser().unescape(result)
		#faultcode tag appears in the resulting xml if some exception comes while making the request
		if "<faultcode>" in parsed_result:
			parsed_result="ops_auto_error"
	except Exception as e:
		logMsg(str(sys.exc_info()[0].__name__)+" Occurred in soapRequester: "+str(e),'ERROR')
		# For debugging
		#print str(sys.exc_info()[0].__name__)+" Occurred in soapRequester: "+str(e)
		parsed_result='ops_auto_error'
	return parsed_result

#If password is wrong then this module will return 'ops_auto_error'
op=soapRequester(xml_data,username,password,url)
if op!='ops_auto_error':
	print "Result Obtained after calling the given url with data passed is\n"
else:
	print "Error while calling the given url\n"
print op

#one more way to unescape string xml
#import xml.sax.saxutils as saxutils
#parsed_op=saxutils.unescape(op)
#print parsed_op




NETWORK

#!/opt/gsperl-5.8.6_1/bin/perl

# IOS Script for Alert Diagnostics
# Net Res Alert Handling Cisco IOS 


my $DEBUG=1;
my $VERBOSE=1;
my $PRINT=1;

# use strict;
use lib "/opt/local/netman_perl/lib/site_perl/5.8.6";
use GSNetConnect;

use Opsware::NAS::Client; # Opsware to access HPNA
use HTTP::Cookies;

my $nas = Opsware::NAS::Client->new();
# nas object is used to get presnapshot and postsnapshot of the device from which alert has come 
# using the IP address of device
my $username = "iconclud"; #HPNA username
my $password = "abc1234"; #HPNA password
my $res = $nas->login
(
 -username => $username,
 -password => $password,
 -host     => "hpna.net.gs.com", # 199.99.0.145
);

my $devicetype = "IOS";
my $log="/opt/local/shared/na/net-res-alert.log";
my $alert = "$alert$";

my ($ip, $user, $password)  = ("$tc_device_ip$", "$tc_device_username$", "$tc_device_password$");

my $ssh = GSNetConnect->connect($ip, $user, $password, $devicetype);
$ssh->settimeout(60);


if($alert =~ m /Interface (Unstable|Down|Disabled)-IF-(.*?VG-.\w+)/){
  voiceInterfaceDown();
} elsif($alert =~ m/Interface Down-IF-/i){
  InterfaceDown();
} elsif($alert =~ m/Interface Unstable-IF-/i){
  InterfaceDown();
} elsif($alert =~ m/Interface BackupActivated-IF-/i){
  InterfaceDown();
} elsif($alert =~ m/NetworkConnection/i){
  InterfaceDown();
} elsif($alert =~ m/BGPSession/i){
  BGP();
} elsif($alert =~ m/BGPService/i){
  BGP();
} elsif($alert =~ m/BGP\ssession/i){
  BGP();
} elsif($alert =~ m/HSRPEndpoint/i){
  HSRP();
} elsif($alert =~ m/OSPFNeighborRelationship/i){
  OSPF();
} elsif($alert =~ m/IPSLA Pkt Loss Detected/i){
  IPSLAPktLoss();
} elsif($alert =~ m/IPSLA Threshold Exceeded/i){
  IPSLA();
} elsif($alert =~ m/IPSLA Threshold Normalized/i){
  IPSLA();
} elsif($alert =~ m/Threshold exceeded/i){
 exceededNMS();
} elsif($alert =~ m/Low threshold breached/i){
 #breachedNMS();
} elsif($alert =~ m/Switch Down-|Switch Unresponsive|Router Down-|Router Unresponsive/i){
  switchDown();
} elsif($alert =~ m/(ERR_DISABLE|PORT_COLLDIS|UDLD_PORT_DISABLED)/i){
  errorDisable();
} elsif($alert =~ m/(Cisco moduleDown|Cisco cefcModuleStatusChange|Card Down|Card SwitchOver-CARD)/i){
  moduleDown();
} elsif($alert =~ m/(Fan StateNotNormal|Cisco cefcFanTrayStatusChange)/i){
  fanDown();
} elsif($alert =~ m/(power supply|PowerSupply)/i){
  powerDown();
} elsif($alert =~ m/(Cold Start|ColdStart|Warm Start|WarmStart)/i){
  cwDown();
} elsif($alert =~ m/WAN/i){
  VitalNetWAN();
} else{
  $VERBOSE and &_logger("No matching actions found for alert \'$alert\'\n");
}

$ssh->disconnect;
exit 0;

# Subs

sub InterfaceDown {
  my $interface_mod1 = $alert;

  # Pulling Interface details from  alert string.
  $interface_mod1 =~ m/\s\[(.*?)\]/;
  $interface_mod1 =  $1;
  #$interface_mod1 =~ s/(T1|T3|E1|Serial)//i;
  #$interface_mod1 =~ s/^\s+|\s+$//g;

  #Picks up the actual formatted interface
  my $interfaceList = join('',$ssh->cmd("show int $interface_mod1"));
  my @interfaceArray = split(/\n/, $interfaceList);
  my $interface = $interfaceArray[0];
  $interface =~ m/(^\w*(\/\d*)*(\D)(\d*)*)/;
  $interface = $1;
  $interface =~ s/^\s+|\s+$//g ;  

  &_logger("Interface Down Diagnostics for $ip Interface $interface_mod1 As $interface.\n");

  if (!$interface_mod1 || !$interface) {
   &_logger("InterfaceDown: Matching interfaces not found. Quitting!");
   return;
  }

  #Interface details will be shown only with actual formatted interface
  my $int_op = join("<br />",$ssh->cmd("sh int $interface | inc proto|Desc|load|Last|que|run|CRC|Internet"));
  
  &_logger("\nInterfaceDown Interface: \n$int_op\n");
  
  $int_op = join("<br />",$ssh->cmd("show interface $interface"));
  
  my @interfaceAddress = $int_op =~ /Internet Address is ((\d+\.\d+\.\d+\.)(\d+))/i;
  my $interfaceIP = @interfaceAddress[0];
  my $otherOctets = @interfaceAddress[1];
  my $lastOctet = @interfaceAddress[2];
  
  
  my $m_val = $lastOctet % 2;
  
  if ($m_val == 0) {
        $lastOctet = $lastOctet - 1;
  } else {
        $lastOctet = $lastOctet + 1;
  }
  
  my $peerIP = $otherOctets.$lastOctet;
  
  
  # Ping
  my $currentoutput4 = "";
  if($interface =~ /Serial/i)
  {
 $currentoutput4 = join("<br />",$ssh->cmd("ping ip $peerIP rep 10 size 1500"));
  }
  else
  {
 $currentoutput4 = join("<br />",$ssh->cmd("ping ip $peerIP rep 10 size 9216"));
  }
  
  my $png= $currentoutput4;
  &_logger("\nPing $peerIP: \n$png\n");
  my @pingParse = $png =~ /(Success rate is (.*) percent.*?\))/i;
  my $summaryPing = @pingParse[0];
  my $summaryPingPercent = @pingParse[1];

  my $clock_out = join("<br />",$ssh->cmd("show clock"));
 
  &_logger("\nInterface Up/Down Logs for ".$interface.": \n");
    getLastLogs("show log | inc $interface");
  
  &_logger("InterfaceDown Clock: $clock_out\n");

 &_logger(join("","\n\n======== SUMMARY ==========\n","Circuit is ",($summaryPingPercent>0)?"UP":"DOWN"," and ping $summaryPing\n========================\n"));
}




sub HSRP {
  my $interface  = "not_init";

  $alert =~ m/HSRPEndpoint SwitchOver.*\[(Group.*?)\]/;
  my $group = $1;

  $interface = join('',$ssh->cmd("show standby | inc $group"));
  $interface =~ s/\s\-.*//;
  chomp($interface);

  &_logger("HSRP Diagnostics for $ip Group $group Interface $interface.\n");
 
  my $clock_op = join("<br />",$ssh->cmd("show clock"));
  &_logger("HSRP Clock: $clock_op\n");

  my $currentoutput = join("<br />",$ssh->cmd("sh standby $interface | in tate|IP|routerTrack|Group"));
  &_logger("\nHSRP Standby Details: \n$currentoutput\n");

#  my $hsrp_int = join('',$ssh->cmd("sh interface $interface | inc Desc|drops|rate|CRC|up|relia|err"));
  my $hsrp_int = join("<br />",$ssh->cmd("sh interface $interface | inc proto|Desc|load|Last|que|run|CRC|Internet"));
  &_logger("\nHSRP Interface: \n$hsrp_int\n");

  my $currentoutput1 = join("<br />",$ssh->cmd("sh standby $interface | inc Track interface"));
  my $trk_interface = "not_init";

  if ($currentoutput1 !~ m/state/) {
    &_logger("HSRP Tracking interface not present.\n");
  } else {
    $trk_interface = $currentoutput1;
    $trk_interface =~ s/.*interface\s//;
    $trk_interface =~ s/\sstate.*//;
    chomp($trk_interface);
    my $trk_int = join("<br />",$ssh->cmd("sh interface $trk_interface | inc Desc|drops|CRC|proto|relia|error|runt"));
    &_logger("\nHSRP Tracking Interface: \n$trk_int\n");
  }

  &_logger("\nHSRP Logs: \n");
  getLastLogs("sh log | inc HSRP.*$interface|HSRP.*$trk_interface");

#  $ssh->print("clear counter");
#  $ssh->print("y");

#  &_logger("HSRP: Cleared counters on $interface\n");
}

sub BGP {
  # Picking up the peer directly from the logs (last log entry) instead of the alert string

  my $peer = $alert;
  my $peera = $alert;

  # Fetching other end peer IP.
  $peer =~ m/(\d+\.\d+\.\d+\.\d+)(.*)|(\d+\.\d+\.\d+\.\d+)\s/;
  $peer = $1;

  # Fetching device own BGP ip.
  $peerb = $peer;

  $peera =~ m/(\d+\.\d+\.\d+\.)(.*)|(\d+\.\d+\.\d+\.\d+)\s/;
  $peera = $1;

  $peerb =~ m/(\d+$)/;
  $peerb = $1;

  my $m_val = $peerb % 2;
  
  if ($m_val == 0) {
        $peerb = $peerb - 1;
  } else {
        $peerb = $peerb + 1;
  }

  my $self_ip = $peera.$peerb;

  &_logger("BGP Diagnostics for device: $ip Peer: $peer of $self_ip.\n");

  #Displaying the device clock.
  my $clock_op = join("<br />",$ssh->cmd("show clock"));
  &_logger("BGP Clock: $clock_op\n");

  # Fetching the peer IP.
  my $bgppeer_op = join("<br />",$ssh->cmd("sh ip bgp nei $peer | inc BGP state|Desc|router"));

  if ($bgppeer_op !~ m/state/) {
    &_logger("IGNORE: No route available for $peer.\n\n");
  return;
  }

  #my $bgppeer_op = join("<br />",$ssh->cmd("sh ip bgp nei $peer"));
  &_logger("\n"."BGP Neigh Desc: \n$bgppeer_op\n");
  
  $bgppeer_op =~ /(BGP state = .*)/i;
  my $summaryStateInformation = $&;

  # Fetching ip route CEF information.
  my $currentoutput1 = join("<br />",$ssh->cmd("sh ip cef $peer"));
  &_logger("\n"."BGP CEF Peer: \n$currentoutput1 \n");

  # Fetching BGP interface details.
  my @BGPInterface = $currentoutput1 =~ /(\S*(Serial|Ethernet|POS|Tunnel|Vlan).*?)(<|\s|,|$)/i;
  my $intt = @BGPInterface[0];
  $intt =~ s/^\s+|\s+$//g ; 
  

  my $int_op = join("<br />",$ssh->cmd("sh int $intt | inc Desc|Int|reli|rate|CRC|prot|count"));
  &_logger("\nBGP Interface: $int_op\n");

  # Fetching interface MTU details.
  my $currentoutput3 = join("<br />",$ssh->cmd("sh int $intt | inc MTU"));
  my $mtuu = $currentoutput3;

  $mtuu =~ m/(\s*(\d*)*\s)/;
  $mtuu = $1;

  # Ping
  my $currentoutput4 = "";
  if($intt =~ /Serial/i)
  {
 $currentoutput4 = join("<br />",$ssh->cmd("ping ip $peer rep 10 size 1500"));
  }
  else
  {
 $currentoutput4 = join("<br />",$ssh->cmd("ping ip $peer rep 10 size 9216"));
  }
  
  my $png= $currentoutput4;
  &_logger("\nPing $peer: \n$png\n");
  my @pingParse = $png =~ /(Success rate is (.*) percent.*?\))/i;
  my $summaryPing = @pingParse[0];
  my $summaryPingPercent = @pingParse[1];

  
  my $clock_out = join("<br />",$ssh->cmd("show clock"));

  $peer =~ s/^\s+|\s+$//g ; 
 
  &_logger("\n"."BGP Device Logs for $peer: \n");
   getLastLogs("sh log | inc $peer");
  
  $intt =~ s/^\s+|\s+$//g ; 
 
  &_logger("\n"."BGP Int Logs for $intt: \n");
  getLastLogs("sh log | inc $intt");
  
  
  &_logger(join("","\n\n======== SUMMARY ==========\n","Circuit is ",($summaryPingPercent>0)?"UP":"DOWN"," and ping $summaryPing\n$summaryStateInformation\n========================\n"));
  

}

sub OSPF {
  my $nbr = "NA";
  my $interface  =  "NA";

  if ($alert =~ m/Nbr\s(.*?)\son\s(.*?)\sis/) {
    $nbr = $1;
    $interface  =  $2;
  } elsif ($alert =~ m/-OSPF-NBR-.*?\[(.*?)\]/) {
    $interface  =  $1; 
    my $nbrString = join('',$ssh->cmd("sh ip ospf nei $interface | i \.")); #extract neighbor id as variable XXX
    $nbrString =~ m/(\d+\.\d+\.\d+\.\d+)/;
    $nbr = $1;
  } else {
    $VERBOSE and &_logger("OSPF: No valid OSPF string match found.\n");
    return;
  }
 
 $int_op_1 = join("<br />",$ssh->cmd("show interface $interface"));
  
  my @interfaceAddress = $int_op_1 =~ /Internet Address is ((\d+\.\d+\.\d+\.)(\d+))/i;
  my $interfaceIP = @interfaceAddress[0];
  my $otherOctets = @interfaceAddress[1];
  my $lastOctet = @interfaceAddress[2];
  
  
  my $m_val = $lastOctet % 2;
  
  if ($m_val == 0) {
        $lastOctet = $lastOctet - 1;
  } else {
        $lastOctet = $lastOctet + 1;
  }
  
  $nbr = $otherOctets.$lastOctet;
  
  &_logger("OSPF Diagnostics for $ip Neighbour $nbr Interface $interface.\n");

  my $clock_op = join("<br />",$ssh->cmd("show clock"));
  &_logger("\n"."OSPF Clock: $clock_op\n");

  #OSPF Neighbor
  my $ospfnei_op = join("<br />", $ssh->cmd("sh ip ospf nei $interface detail | inc Neighbor"));
  &_logger("\n"."OSPF Neighbour: \n$ospfnei_op\n");
  
  my $summaryStateInformation = join("<br />",$ssh->cmd("sh ip ospf nei $interface detail | inc  Neighbor is"));

  # Neighbor Ping
  
    my $currentoutput4 = "";
  if($interface =~ /Serial/i)
  {
 $currentoutput4 = join("<br />",$ssh->cmd("ping ip $nbr rep 10 size 1500"));
  }
  else
  {
 $currentoutput4 = join("<br />",$ssh->cmd("ping ip $nbr rep 10 size 9216"));
  }
  
  my $png= $currentoutput4;
  &_logger("\nPing $nbr: \n$png\n");
  
  my @pingParse = $png =~ /(Success rate is (.*) percent.*?\))/i;
  my $summaryPing = @pingParse[0];
  my $summaryPingPercent = @pingParse[1];

  my $int_op = join("<br />",$ssh->cmd("sh int $interface | inc proto|Desc|load|Last|que|run|CRC|Internet"));
  &_logger("<br />"."OSPF Int: \n$int_op\n");

  my $clock_out = join("<br />",$ssh->cmd("show clock"));

  $nbr =~ s/^\s+|\s+$//g ; 
  
  &_logger("\n"."OSPF Int Logs for $nbr: \n");
  getLastLogs("sh log | inc $nbr");
  
  $interface =~ s/^\s+|\s+$//g ; 

  &_logger("\n"."OSPF Int Logs for $interface: \n");
  getLastLogs("sh log | inc $interface");

#  $ssh->print("clear counter");
#  $ssh->print("y");

#  &_logger("OSPF: Cleared counters\n");
&_logger(join("","\n\n======== SUMMARY ==========\n","Circuit is ",($summaryPingPercent>0)?"UP":"DOWN"," and ping $summaryPing\n$summaryStateInformation\n========================\n"));
}


sub VitalNetWAN {

  my $interface_mod1 = $alert;

  $interface_mod1 =~ m/\_(.*?)\_/;
  $interface = $1;

  #Picks up the actual formatted interface
  #my $interfaceList = join('',$ssh->cmd("show int descr | inc $interface_mod1"));
  #my @interfaceArray = split(/\n/, $interfaceList);
  #my $interface = $interfaceArray[0];
  #$interface =~ m/(.*?)\s\s+/;
  #$interface = $1;

  &_logger("Interface Diagnostics for Interface $interface .\n");

  #Interface details will be shown only with actual formatted interface

  #my $int_op = join("<br />",$ssh->cmd("show interface $interface | inc proto|Desc|load|count|err|run|drop"));
  my $int_op = join("<br />",$ssh->cmd("show interface $interface"));
  &_logger("\nInterface: \n$int_op\n");

  my $int_cdp = join("<br />",$ssh->cmd("show cdp nei $interface"));
  &_logger("\nCDP: \n$int_cdp\n");
  
  #Log search needs actual alert string interface
  my $log_op = join("<br />",$ssh->cmd("show log | inc $interface")); 
  &_logger("\nInterfaceDown Logs: \n$log_op\n");

#  #$ssh->print("clear counters $interface");
#  #$ssh->print("y");
#  #&_logger("Interface: Cleared counters on $interface\n");

}

sub IPSLAPktLoss{

 my $interface_text1 = $alert;

 $interface_text1 =~ m/to (.*)/;
 my $Other_end =$1;
 $Other_end =~ s/^\s+|\s+$//g;

 # Picks up the other end from the alert summary

 my $Output_Log1 = join("<br />",$ssh->cmd("show run | inc $Other_end"));
 &_logger($Output_Log1."\n");

 $Output_Log1 =~ m/sip=(.*)\|/i;
 my $SourceIP = $1;

 &_logger("Source IP: $SourceIP\n");

 $Output_Log1 =~ m/dip=(.*)/i;
 my $DestinationIP = $1;

 &_logger("Destination IP: $DestinationIP\n");

 $SourceIP =~ s/^\s+|\s+$//g;
 $DestinationIP =~ s/^\s+|\s+$//g;

 my $Output_Log2 = join("<br />",$ssh->cmd("ping ip $DestinationIP source $SourceIP repeat 100"));

 &_logger( "Output of Ping:<br />$Output_Log2 \n" );

}


sub IPSLA{
 my $interface_text1 = $alert;

 $interface_text1 =~ m/to (.*?) -/;
 my $Other_end =$1;
 $Other_end =~ s/^\s+|\s+$//g;

 # Picks up the other end from the alert summary

 my $Output_Log1 = join("<br />",$ssh->cmd("show run | inc $Other_end"));
 &_logger($Output_Log1."\n");

 $Output_Log1 =~ m/sip=(.*)\|/i;
 my $SourceIP = $1;

 &_logger("Source IP: $SourceIP\n");

 $Output_Log1 =~ m/dip=(.*)/i;
 my $DestinationIP = $1;

 &_logger("Destination IP: $DestinationIP\n");

 $SourceIP =~ s/^\s+|\s+$//g;
 $DestinationIP =~ s/^\s+|\s+$//g;

 my $Output_Log2 = join("<br />",$ssh->cmd("ping ip $DestinationIP source $SourceIP repeat 100"));

 &_logger( "Output of Ping:<br />$Output_Log2 \n" );
}

sub voiceInterfaceDown{

 my $interface_mod1 = $alert;

 # Pulling Interface details from  alert string.
 #$interface_mod1 =~ m/\[(.*)(\d.*?)\]/;
 $interface_mod1 =~ m/\[(.*?)(\d*\/.*?)\]/;
 $interfaceType = $1;
 $interfaceNum = $2; 
 $interfaceType =~ s/^\s+|\s+$//g;
 $interfaceNum =~ s/^\s+|\s+$//g;

 # this is the Old script with old command commented on 30th January

 # if ($interfaceType == "T1") 
 # {
 # my $interfaceList1 = join('',$ssh->cmd("show controllers $interfaceType $interfaceNum brief"));
 # &_logger("Interface  Status Diagnostics for $interfaceNum :\n$interfaceList1\n");

 # my $interfaceList1 = join('',$ssh->cmd("show  isdn status serial $interfaceNum:23"));
 # &_logger("Interface  Status Diagnostics for $interfaceNum :\n$interfaceList1\n");
 # }

 # elsif ($interfaceType == "DS0 Group")
 # {
 # my $interfaceList1 = join('',$ssh->cmd("show controllers $interfaceType $interfaceNum brief"));
 # &_logger("Interface  Status Diagnostics for $interfaceNum :\n$interfaceList1\n");

 # my $interfaceList1 = join('',$ssh->cmd("show isdn status serial $interfaceNum"));
 # &_logger("Interface  Status Diagnostics for $interfaceNum :\n$interfaceList1\n");
 # }
 # elsif(($interfaceType == "E1") ||($interfaceType == "Se"))
 # {

 # my $interfaceList1 = join("<br />",$ssh->cmd("show controllers $interfaceType $interfaceNum brief"));
 # my @interfaceArray = split(/\n/, $interfaceList1);
 # my $interface = $interfaceArray[0];

 # the below line was commented before

 # &_logger("Interface Status Diagnostics for $interfaceNum :\n$interface\n");
 # &_logger("Interface  Status Diagnostics for $interfaceNum as :\n$interfaceList1\n");



 # my $interfaceList1 = join("<br />",$ssh->cmd("show isdn status serial $interfaceNum:15"));
 # &_logger("Interface  Status Diagnostics for $interfaceNum as :\n$interfaceList1\n");

 # }

 # elsif (($interfaceType == "E&M") ||($interfaceType == "CAS") ||($interfaceType == "Foreign Exchange Station"))
 # {
 # my $interfaceList1 = join('',$ssh->cmd("show voice port $interfaceNum"));
 # &_logger("Interface  Status Diagnostics for $interfaceNum :\n$interfaceList1\n");

 # my $interfaceList1 = join('',$ssh->cmd("show voice port summary | inc $interfaceNum"));
 # &_logger("Interface  Status Diagnostics for $interfaceNum as :\n$interfaceList1\n");

 # }

 &_logger("InterfaceNum: $interfaceNum , InterfaceType: $interfaceType\n");
 # this is the New Script with New commands:
 
 if ($interfaceType eq "T1") 
 {
  my $log_op = join("<br />",$ssh->cmd("show controllers t1 $interfaceNum"));
  my $last_six_lines = getLastNLines(6,$log_op);
  &_logger($last_six_lines."\n");
 }

 elsif (($interfaceType eq "DS0 Group")||($interfaceType eq "E&M")||($interfaceType eq "CAS")||($interfaceType eq "Foreign Exchange Station"))
 {
  my $log_op = join("<br />",$ssh->cmd("show voice port $interfaceNum"));
  my $last_six_lines = getLastNLines(6,$log_op);
  &_logger($last_six_lines."\n");

  my $log_op2 = join("<br />",$ssh->cmd("show voice port summary | i $interfaceNum"));
  my $last_six_lines = getLastNLines(6,$log_op2);
  &_logger($last_six_lines."\n");
 }
  elsif($interfaceType eq "E1")
 {
  my $log_op = join("<br />",$ssh->cmd("show controllers e1 $interfaceNum"));
  my $last_six_lines = getLastNLines(6,$log_op);
  &_logger($last_six_lines."\n");

  my $log_op2 = join("<br />",$ssh->cmd("show isdn status serial $interfaceNum:15"));
  my $last_six_lines = getLastNLines(6,$log_op2);
  &_logger($last_six_lines."\n");
 }
 elsif($interfaceType eq "Se")
 {
  #my $interfaceList1 = join('',$ssh->cmd("show controllers $interfaceType $interfaceNum brief"));
  #&_logger("Interface  Status Diagnostics for $interfaceNum as $interfaceList1 \n");

  my $log_op2 = join("<br />",$ssh->cmd("show isdn status serial $interfaceNum"));
  my $last_six_lines = getLastNLines(6,$log_op2);
  &_logger($last_six_lines."\n");
 }
 #elsif (($interfaceType == "E&M") ||($interfaceType == "CAS") ||($interfaceType == "Foreign Exchange Station"))
 #{
  #my $interfaceList1 = join('',$ssh->cmd("show voice port $interfaceNum"));
  #&_logger("Interface  Status Diagnostics for $interfaceNum as $interfaceList1 \n");

  #my $interfaceList2 = join('',$ssh->cmd("show voice port summary | inc $interfaceNum"));
  #&_logger("Interface  Status Diagnostics for $interfaceNum as $interfaceList2 \n");
 #}
 
 #Get the Time of the day:
 my $clock_out = join("<br />",$ssh->cmd("show clock"));

 &_logger("\nInterface Up/Down Logs for ".$interfaceNum.": \n");
 getLastLogs("show log | inc $interfaceNum");

}


#open NMS script added on Jan 30th
sub exceededNMS {
 
 my $interface_mod1 = $alert;

  # Pulling Interface details from  alert string.
 
  $interface_mod1 =~ m/\s(\S*\/\S*?)(\s|,)/i;
  $interface_mod1 =  $1;
 
  #Picks up the actual formatted interface
  my $interfaceList = join('',$ssh->cmd("show int $interface_mod1"));
  my @interfaceArray = split(/\n/, $interfaceList);
  my $interface = $interfaceArray[0];
  $interface =~ m/(^\w*(\/\d*)*(\D)(\d*)*)/;
  $interface = $1;
  $interface =~ s/^\s+|\s+$//g ;  
  #&_logger("Interface Down Diagnostics for $ip Interface $interface_mod1 As $interface.\n");
  if (!$interface_mod1 || !$interface) {
   &_logger("InterfaceDown: Matching interfaces not found. Quitting!");
   return;
  }
 my $interfaceOutput = join("<br />",$ssh->cmd("show int $interface"));
 &_logger("Show Interface of $interface: \n$interfaceOutput\n");
 
 #Get the Time of the day:
 my $clock_out = join("<br />",$ssh->cmd("show clock"));
 &_logger("Logs on Interface $interface: \n");
 getLastLogs("show log | inc $interface");
 &_logger("==================================================\n");
 
 &_logger("Clock: $clock_out\n");
 &_logger("==================================================\n");

}


#open NMS script added on Jan 30th

sub breachedNMS{
 
 my $alert_text = $alert;
 
 #Get the Time of the day:
 my $clock_out = join("<br />",$ssh->cmd("show clock"));
 &_logger("\nLogs: \n");
 getLastLogs("show log");
 &_logger("==================================================\n"); 
 
 &_logger("Clock Output: $clock_out\n");
 &_logger("==================================================\n"); 
  

 my $memory = join("<br />",$ssh->cmd("sh memory | i Largest|Processor|I/O"));
 $memory =~ m/(.*)Processor memory /;
 $memory = $1;
 &_logger("Memory Status output: $memory\n");
 &_logger("==================================================\n"); 

 my $memDead = join("<br />",$ssh->cmd("show memory dead | i Largest|Processor|I/O"));
 $memDead =~ m/(.*)Processor memory /;
 $memDead = $1;
 &_logger("Dead Memory output: $memDead\n"); 

}


sub errorDisable(){
 $alert =~ /\s(\S*\/\S*?)(\s|,)/i;
 my $interface = $1;
 $interface =~ /.*?(\d.*)/;
 my $Logginginterface = $1; 
 if($alert =~ /PORT_COLLDIS/i)
 {
   &_logger("\nError Disable Logs for Port ".$Logginginterface.": \n");
   getLastLogs("show logging buffer 1023 | inc $Logginginterface"); 
   my $sh_int_op = join("<br />",$ssh->cmd("show port $Logginginterface"));
   &_logger("<br />"."Error Disable Show Interface Output on Port $Logginginterface: \n$sh_int_op\n");
 }
 else
 {
   &_logger("\nError Disable Logs for ".$Logginginterface.": \n");
   getLastLogs("show log | inc $Logginginterface"); 
   my $sh_int_op = join("<br />",$ssh->cmd("sh int $interface"));
   &_logger("<br />"."Error Disable Show Interface Output on $interface: \n$sh_int_op\n");
 }
 
}

 sub fanDown()
 {
   &_logger("\nLogs : \n");
   getLastLogs("show log"); 
   my $sh_int_op = join("<br />",$ssh->cmd("show environment | inc Fantray|fan-tray"));
   &_logger("<br />"."Show Environment Output for Fan: \n$sh_int_op\n");
 }
 
 #Network Hardware Alerts- Power Supply Failure 
 sub powerDown()
 {
   &_logger("\nLogs : \n");
   getLastLogs("show log"); 
   my $sh_int_op = join("<br />",$ssh->cmd("show environment | inc PS|power-supply"));
   &_logger("<br />"."Show Environment Output for Power Supply: \n$sh_int_op\n");
 }
 
 
# Network Hardware Alert Resolution for module Down
sub moduleDown()
{ 
 my @diff_op=();
 my $sh_version = join("<br />",$ssh->cmd("show version | inc (Uptime|uptime)"));
 &_logger("\n---------------------------------------------------\n");
 &_logger("<br />"."Device Uptime output is : \n$sh_version\n");
 &_logger("\n---------------------------------------------------\n");
 if( $alert =~ m/(Cisco moduleDown)/i)
 {
  my ($module_no)=$alert=~ /(\d+)/;
  my $sh_module_no = join("<br />",$ssh->cmd("show module $module_no"));
  &_logger("\n---------------------------------------------------\n");
  &_logger("<br />"."Module Down Show Module $module_no output is : \n$sh_module_no\n");
  &_logger("\n---------------------------------------------------\n");
 }

  my ($module_and_interface_diag_preref, $module_and_interface_diag_postref)=showModule_and_InterfaceDiag();
 if(@$module_and_interface_diag_preref and @$module_and_interface_diag_postref)
 {
  &_logger("\n---------------------------------------------------\n");
  &_logger("Link for the difference between module and interface pre diagnostic and post diagnostic is \n");
  getDiffToolLink($module_and_interface_diag_preref,$module_and_interface_diag_postref);
  &_logger("\n---------------------------------------------------\n");
 }
 else
 {
  &_logger("\n---------------------------------------------------\n");
  &_logger("\n Run Diagnostic Failed for both NA Module Status and NA Interfaces\n");
  &_logger("\n---------------------------------------------------\n");
 }

 my ($old_config_ref, $recent_config_ref)=showRecentTwoSnapshots();

 if(@$old_config_ref and @$recent_config_ref)
 {
  &_logger("\n---------------------------------------------------\n");
  &_logger("Link for the difference between Last Snapshot Config and Recent Config is\n");
  getDiffToolLink($old_config_ref,$recent_config_ref);
  &_logger("\n---------------------------------------------------\n");
  @diff_op=intelligentDiff($old_config_ref,$recent_config_ref);
  &_logger("\n----------Intelligent Diff Output for Pre config snapshot and Post Config snapshot is------------");
  if(@diff_op) #if there is difference in pre and post snapshot then array will not be empty
  {
   if(grep /^Error\s/ , $diff_op[0])
   {
    &_logger("\n$diff_op[0]\n");
   }
   else
   {
    &_logger("\n @diff_op \n");
   }
  }
  else # array empty means both pre and post snapshot are same
  {
   &_logger("\n Both pre Snapshot and post Snapshot of the device are same\n");
  }
 }
 else
 {
  print("\n Getting current configuration of the device failed \n");
 }
}
#End of moduleDown Function

#Network Hardware Alert resolution- Switch Down/ Router Down 
sub switchDown()
{
 $alert =~ /(\S*\.gs.com)/i;
 my $interface = $1;
 my $sh_int_op = join("<br />",$ssh->cmd("show version | inc (uptime|Uptime)"));
 &_logger("\n---------------------------------------------------\n");
 &_logger("<br />"." Uptime of $interface: \n$sh_int_op\n");
 &_logger("\n---------------------------------------------------\n");

 my ($module_and_interface_diag_preref, $module_and_interface_diag_postref)=showModule_and_InterfaceDiag();
 if(@$module_and_interface_diag_preref and @$module_and_interface_diag_postref)
 {
  &_logger("\n---------------------------------------------------\n");
  &_logger("Link for the difference between module and interface pre diagnostic and post diagnostic is \n");
  getDiffToolLink($module_and_interface_diag_preref,$module_and_interface_diag_postref);
  &_logger("\n---------------------------------------------------\n");
 }
 else
 {
  &_logger("\n---------------------------------------------------\n");
  &_logger("\n Run Diagnostic Failed for both NA Module Status and NA Interfaces\n");
  &_logger("\n---------------------------------------------------\n");
 }
 my ($old_config_ref, $recent_config_ref)=showRecentTwoSnapshots();

 if(@$old_config_ref and @$recent_config_ref)
 {
  &_logger("\n---------------------------------------------------\n");
  &_logger("Link for the difference between Last Snapshot Config and Recent Config is\n");
  getDiffToolLink($old_config_ref,$recent_config_ref);
  &_logger("\n---------------------------------------------------\n");
 }
 else
 {
  print("\n Getting current configuration of the device failed \n");
 }
}


#Network Hardware Alert Resolution - Cold start and Warm start 

sub cwDown()
{
 $alert =~ /(\S*\.gs.com)/i;
 my $interface = $1;
 my $sh_int_op = join("<br />",$ssh->cmd("Show Version | inc (uptime|Uptime)")); 
 &_logger("\n---------------------------------------------------\n");
 &_logger("<br />"." Uptime of $interface: \n$sh_int_op\n");
   
 my ($module_and_interface_diag_preref, $module_and_interface_diag_postref)=showModule_and_InterfaceDiag();
 if(@$module_and_interface_diag_preref and @$module_and_interface_diag_postref)
 {
  &_logger("\n---------------------------------------------------\n");
  &_logger("Link for the difference between module and interface pre diagnostic and post diagnostic is \n");
  getDiffToolLink($module_and_interface_diag_preref,$module_and_interface_diag_postref);
  &_logger("\n---------------------------------------------------\n");
 }
 else
 {
  &_logger("\n---------------------------------------------------\n");
  &_logger("\n Run Diagnostic Failed for both NA Module Status and NA Interfaces\n");
  &_logger("\n---------------------------------------------------\n");
 }
 my ($old_config_ref, $recent_config_ref)=showRecentTwoSnapshots();

 if(@$old_config_ref and @$recent_config_ref)
 {
  &_logger("\n---------------------------------------------------\n");
  &_logger("Link for the difference between Last Snapshot Config and Recent Config is\n");
  getDiffToolLink($old_config_ref,$recent_config_ref);
  &_logger("\n---------------------------------------------------\n");
 }
 else
 {
  print("\n Getting current configuration of the device failed \n");
 }

}

sub getLastLogs {
 my $logCommand = shift(@_);
 my $log_op = join("<br />",$ssh->cmd($logCommand));
 my $last_six_lines = getLastNLines(6,$log_op);
 &_logger($last_six_lines."\n");
}

sub getLastNLines {
 my $numberOfLines = shift(@_);
 my $string = shift(@_);
 my @log_split = split(/<br \/>/,$string);
 my $last_N_lines = join("<br />",(($numberOfLines >= @log_split) ? @log_split : @log_split[(-1*$numberOfLines)..-1]));
 return $last_N_lines;
}

#intelligentDiff module finds the difference between two arrays passed as references in arguments
sub intelligentDiff
{
 (my $presnapref,my $postsnapref)=@_;
 my @presnap=@$presnapref;
 my @postsnap=@$postsnapref;
 my $error_str="";# local variable local to function
 my @file1_lines=();
 my @file2_lines=();
 my @return_arr=();
 # writing pre snap and post snap to temporary files because unix diff accepts two files as arguments
 if(@presnap and @postsnap) 
 {
  my $prefile='prefile.txt';
  open (FILE,"> $prefile");
  print FILE @presnap;
  close FILE;
  my $postfile='postfile.txt';
  open (FILE1,"> $postfile");
  print FILE1 @postsnap;
  close FILE1;
  if((-e $prefile) and (-e $postfile))
  {
   my $diff_var = `diff -u $prefile $postfile`;
   if($diff_var ne "")
   {
    my $counter1=1; # counter to print line numbers for first file
    my $counter2=1; # counter to print line numbers for second file
    my $counter1_last=1;
    my $counter2_last=1;
    my @diff_arr=split("\n",$diff_var); # splitting the output of diff on the basis of new line and getting it into an array
    if(@diff_arr)
    {
     my $ip_info=sprintf "%-80s","PreSnap_$ip";
     $ip_info.=" |PostSnap_$ip\n";
     push(@return_arr,$ip_info); #printing the header
     for my $index ( 2..$#diff_arr) 
     {
      my $row=$diff_arr[$index];
      if($row =~ m/^[\@\@]+/) #matching the regex on unix_unified_diff to know from where change started
      {
       my @all_nums = $row =~ /(\d+)/g;
       $counter1=$all_nums[0]-1;
       $counter2=$all_nums[2]-1;
       next;
      }
      if($row =~ m/^[\-]+/)# matching the regex to know which lines are deleted
      {
       $counter1++;
       $row=~ s/^.//; #to remove the "-" symbol from the output of unix-Diff
       push(@file1_lines,"$counter1 $row");
       $counter1_last=$counter1; # to calculate the last changed line in first file     
      }
      elsif($row =~ m/^[\+]+/)# matching the regex to know which lines are inserted
      { 
       $counter2++;
       $row=~ s/^.//; #to remove the "+" symbol from the output of unix-Diff
       push(@file2_lines,"$counter2 $row");
       $counter2_last=$counter2; # to calculate the last changed line in second file
      }
      else # the lines which are common in both of files for those just increase the counter
      {
       $counter1++;
       $counter2++;
      }
     }
     my $end=$counter2_last;
     if($counter1_last>$counter2_last) #calculating the max of counter1_last and counter2_last
     {
      $end=$counter1_last;
     }
     # applying loop from starting to max of last line changed in file1 and file2
     # and finding if a change happened at same line then print side by side otherwise print in next line
     my @temp_arr="";
     for my $i(0..$end)
     {
      my $temp_var=sprintf "%-80s"," ";
      if( grep /^$i\s/, @file1_lines)
      {
       @temp_arr=grep /^$i/,@file1_lines;
       $temp_var=sprintf "%-80s", $temp_arr[0];
      }
      if( grep /^$i\s/, @file2_lines)
      {
       @temp_arr=grep /^$i/,@file2_lines;
       $temp_var.=" |$temp_arr[0]";
      }
      if ($temp_var and $temp_var =~ /\S/) 
      {
       push(@return_arr,"$temp_var\n");
      }
     }    
    }
    else
    {
     $error_str="Error - Unable to split unix diff on the basis of new Line"; #Enable this for Debugging
     push(@return_arr,$error_str);
    }
   }
   else
   {
    @return_arr=();# returns empty array if there is no difference
   }
  }
  else
  {
   $error_str="Error - Unable to write pre snap or post snap to files";
   push(@return_arr,$error_str);
  }
  unlink $prefile;
  unlink $postfile;
 }
 else
 {
  $error_str="Error - Unable to find pre or post snapshot array reference"; 
  push(@return_arr,$error_str);
 }
 return (@return_arr);
}
#End of intelligentDiff Module
#===============================================================================
sub showRecentTwoSnapshots
{
my @recent_config_arr=();
my @old_config_arr=();
my $config_old_date="";
my $config_recent_date="";
my $list_config_res = $nas->list_config( ip => $ip)->results();

@$list_config_res = sort { $b->{createDate} cmp $a->{createDate} } @$list_config_res; 

my @all_nums = $alert =~ /(\d+)/g;
my $get_snapshot_return_code=$all_nums[$#all_nums-2];

$config_recent_date=$list_config_res->[0]->{"createDate"};
$config_old_date=$list_config_res->[1]->{"createDate"};
            

 if ($get_snapshot_return_code)
 {

 my $show_task_res = $nas->show_task ( 'id' => $get_snapshot_return_code )->results();
 my $start_date_time = $show_task_res->[0]->{"startDate"};
 my $end_date_time = $show_task_res->[0]->{"completeDate"};
  
  my $recent_config_diag_id = $list_config_res->[0]->{"deviceDataID"};
  my $recent_show_config_res = $nas->show_config( 'id' => $recent_config_diag_id );
  my $latest_config = $recent_show_config_res->[0][0];
  
  if((($config_recent_date cmp $start_date_time)==1) && (($config_recent_date cmp $end_date_time)==-1))
 {

  push(@recent_config_arr,"*****Recent Configuration $config_recent_date Output Starts here *****\n $latest_config \n");

  my $old_config_diag_id = $list_config_res->[1]->{"deviceDataID"};
  my $old_show_config_res = $nas->show_config( 'id' => $old_config_diag_id);
  my $old_config = $old_show_config_res->[0][0];
  push(@old_config_arr,"*****Old Configuration $config_old_date Output Starts here *****\n $old_config \n");
 }
 else
 { 
  push(@old_config_arr,"****Old Configuration Snapshot ($config_recent_date) NO DIFF FOUND!!! *****\n $latest_config \n");
  push(@recent_config_arr,"****Recent Configuration Snapshot ($end_date_time) NO DIFF FOUND!!! *****\n $latest_config \n");
 }

 }

return (\@old_config_arr,\@recent_config_arr);
}
#====================================================================================================
sub showModule_and_InterfaceDiag
{
my @return_arr=();
my @return_arr2=();
my $moduleres = $nas->list_diagnostic( ip => $ip,diagnostic => "NA Module Status" )->results(); 
my $interface_res = $nas->list_diagnostic( ip => $ip,diagnostic => "NA Interfaces" )->results(); 


@$interface_res = sort { $b->{createDate} cmp $a->{createDate} } @$interface_res; 
@$moduleres = sort { $b->{createDate} cmp $a->{createDate} } @$moduleres;
my @all_nums = $alert =~ /(\d+)/g;
my $interface_return_code=$all_nums[$#all_nums];
my $module_return_code=$all_nums[$#all_nums-1];
my $interface_recent_date=$interface_res->[0]->{"createDate"};
my $interface_old_date=$interface_res->[1]->{"createDate"};

my $module_recent_date=$moduleres->[0]->{"createDate"};
my $module_old_date=$moduleres->[1]->{"createDate"};   
if(($module_return_code) or ($interface_return_code))
{
if ($module_return_code)
{
 my $show_task_res = $nas->show_task ( 'id' => $module_return_code )->results();
 my $start_date_time = $show_task_res->[0]->{"startDate"};
 my $end_date_time = $show_task_res->[0]->{"completeDate"};
 my $recent_na_module_diag_id = $moduleres->[0]->{"deviceDataID"};
   my $module_show_diag_res1 = $nas->show_diagnostic ( 'id' => $recent_na_module_diag_id );
   my $module_diags1 = $module_show_diag_res1->[0][0];
 if((($module_recent_date cmp $start_date_time)==1) && (($module_recent_date cmp $end_date_time)==-1))
 {
   
   push(@return_arr,"*****Recent NA Module Status Diagnostic $module_recent_date Output Starts here *****\n $module_diags1 \n");


   my $old_na_module_diag_id = $moduleres->[1]->{"deviceDataID"};
   my $module_show_diag_res2 = $nas->show_diagnostic ( 'id' => $old_na_module_diag_id );
   my $module_diags2 = $module_show_diag_res2->[0][0];
   push(@return_arr2,"*****Old NA Module Status Diagnostic $module_old_date Output Starts here *****\n $module_diags2 \n");
 }
 else
 {
 push(@return_arr,"****Recent NA Module ($end_date_time) Status NO DIFF FOUND!!! *****\n $module_diags1 \n");
  push(@return_arr2,"****Old NA Module ($module_recent_date) Status NO DIFF FOUND!!! *****\n $module_diags1\n");
 }
}
else
{
  push(@return_arr,"****Recent NA Module Status Diagnostic failed *****\n");
  push(@return_arr2,"****Old NA Module Status Diagnostic not captured *****\n");
}

if ($interface_return_code)
{
 my $show_task_res = $nas->show_task ( 'id' => $interface_return_code )->results();
 my $start_date_time = $show_task_res->[0]->{"startDate"};
 my $end_date_time = $show_task_res->[0]->{"completeDate"};
 my $diag_id1 = $interface_res->[0]->{"deviceDataID"};
  my $res1 = $nas->show_diagnostic ( 'id' => $diag_id1 );
  my $interface_diags1 = $res1->[0][0];
 if((($interface_recent_date cmp $start_date_time)==1) && (($interface_recent_date cmp $end_date_time)==-1))
 {
  
  push(@return_arr,"*****Recent NA Interface Diagnostic $interface_recent_date Output Starts here *****\n $interface_diags1");

  my $diag_id2 = $interface_res->[1]->{"deviceDataID"};
  my $res2 = $nas->show_diagnostic ( 'id' => $diag_id2 );
  my $interface_diags2 = $res2->[0][0];
  push(@return_arr2,"*****Old NA Interface Diagnostic $interface_old_date Output Starts here *****\n $interface_diags2");
 }
 else
 {
  push(@return_arr,"****Recent NA Interface ($end_date_time) Status NO DIFF FOUND!!! *****\n $interface_diags1 \n");
  push(@return_arr2,"****Old NA Interface ($interface_recent_date) Status NO DIFF FOUND!!! *****\n $interface_diags1 \n");
 }
}
else
{
  push(@return_arr,"****Recent NA Interfaces Diagnostic failed *****\n");
  push(@return_arr2,"****Old NA Interfaces Diagnostic not captured *****\n");
}
}

return (\@return_arr2,\@return_arr);
}

# this module generates the diff Tool link after getting the pre snapshot and 
#post snapshot reference which are passed as input parameters to this module

sub getDiffToolLink
{
 (my $pre_snap_arr_ref,my $post_snap_arr_ref)=@_;
 if(($pre_snap_arr_ref ne "") and ($post_snap_arr_ref ne ""))
 {
  my @pre_snap=@{$pre_snap_arr_ref};
  my @post_snap=@{$post_snap_arr_ref};
  my $preStringFileName="";
  my $postStringFileName="";
  my $browser=LWP::UserAgent->new;
  my $cookies=HTTP::Cookies->new;
  my $temp=`curl -i -s -x '' -k -e 'http://home.gs.com/' -d username=tsonetuser -d password=redhat123* -d referpg=aHR0cDovL2NkY2lwbG0wMS5ueS5mdy5ncy5jb20vbmlzLw== https://webid.is.gs.com/cgi-bin/V4/authenticate.cgi`;
  "a" =~ /a/; 
  $temp=~ /GSSSO=(.*?);/;
  my $cookieval=$1;
  my $preString=join("\n",@pre_snap);
  my $postString=join("\n",@post_snap);
  if($cookieval ne "")
  {
   $cookies->set_cookie(0,'GSSSO',$cookieval,'/','.gs.com');
   $browser->cookie_jar($cookies);
   $preStringFileName="PreSnap_$ip";
   $postStringFileName="PostSnap_$ip";
   my $response=$browser->post("http://d152084-001.dc.gs.com:8080/quickdiff/Web-Content/JSP/diffGen.jsp",
   ['preString'  => $preString,
    'postString' => $postString,
    'preStringFileName'=>$preStringFileName,
    'postStringFileName'=>$postStringFileName]);
    
   my $resp_code=$response->code;
   
   if($resp_code==200)
   {
    my $new_resp=$response->request->uri;
    &_logger("\n$new_resp    -  OPEN LINK IN GOOGLE CHROME\n");
   }
   elsif($resp_code==302)
   {
    my $linkref=$response->header('location');
    &_logger("\n$linkref    -  OPEN LINK IN GOOGLE CHROME\n");
   }
   else
   {
    &_logger ("\n Unable to find Diff Tool Link \n");
   }
  }
  else
  {
   &_logger("\n Unable to find cookie to login on Diff Tool\n");
  }
 }
 else
 {
  &_logger("\n Unable to receive Pre Snapshot or Post Snapshot\n"); 
 }
}

sub _logger {
        my ($sec,$min,$hour,$day,$mon,$year,$wday,$yday,$isdst) = localtime(time);
        my $timestamp = sprintf("%4d-%02d-%02d %02d:%02d:%02d ", $year+1900,$mon+1,$day,$hour,$min,$sec);
        open(LOG, ">>$log") or print "Couldn't open log $log\n";
        print LOG $timestamp . join( q{ }, @_);
        close(LOG);
        $PRINT and print join( q{ }, @_);
};


UNIX

#! /gns/mw/lang/python/python-2.7.2-gns.03/bin/python
#-----------------------------------------------------------------------------------------------------------------------------
# DESCRIPTION   : Python Script for Business Readiness Check
# TRACK         : UNIX
# AUTHOR        : Vikash Kumar
# DATE          : 19 November, 2015
# VERSION       : 1.0
#-----------------------------------------------------------------------------------------------------------------------------
# MODULES USED
#-----------------------------------------------------------------------------------------------------------------------------
import getopt,sys,os,re,socket
import datetime,time
from datetime import timedelta
#sys.path.append('/gns/mw/lang/python/python-2.7.2-gns.03/lib/python2.7')
#-----------------------------------------------------------------------------------------------------------------------------
# VARIABLES
#-----------------------------------------------------------------------------------------------------------------------------
logfile_directory = "/home/tsotools/iauto_hwcheck_logs/"

# POWERPATH AND MULTIPATH VARIABLE

power_path_li = "/sbin/powermt"
power_path_so = "/etc/powermt"
multi_path = "/sbin/multipath"
journal = " "
os_type = 0
log_path = "/var/log/nagios/agent.log"
config1_path = "/local/opt/nagios-agent/etc/nagios-agents.cfg"
config2_path = "/opt/nagios-agent/etc/nagios-agents.cfg"
gns_agent_path = "/gns/software/infra/monitoring/nagios-current/init-nagios-agent"
gns_perl_path = "/gns/mw/lang/perl/perl-5.10-3/bin/perl"
gns_recovery_path = "/gns/appdata/software/infra/monitoring/nagios/vault/recovery.sh"
#-----------------------------------------------------------------------------------------------------------------------------
def scriptUsage():
	print("""usage : <scriptname> { -f/--hostfile hostname/server_lis_file } [ -H/--hardware ] [ -S/--software ] [-L/--loglevel 0/1/2]

Optional positional arguments:

--hardware or -H	: Perform Hardware Checks
--software or -S	: Perform Software Checks

--network or -I		: Check Network Interfaces
--disk or -d		: Check Physical & Logical Disk
--path or -D		: Check Multipath and Powerpath
--storage or -s		: Checks Storage & Battery Status
--memory or -m  	: Checks Memory
--cpu or -c     	: Checks CPU Status
--fans or -F    	: Checks Fan Status
--logs or -l		: Check Logs
--power or -p		: Check Power Supply Status
--temp or -t		: Check Temperature
--os or -o		: Check OS-Version
--cfe or -C		: Check CFE Status
--nagios or -n		: Check Nagios Status
--ntp or -N		: Check NTP Status
--pre or -P		: Pre-Checks for maintenance or change [ pass with option -H or -S or -I -d etc.]
--post or -M		: Post-Checks to be validated with Pre-Checks [ pass with option -H or -S or -I -d etc.]
--help or -h		: Print Script Usage
--loglevel or -L	: Set Log level for Debugging (0/1/2, by default is 1)
""")
	exit(1)
#-----------------------------------------------------------------------------------------------------------------------------
# FUNCTIONS
#-----------------------------------------------------------------------------------------------------------------------------
# 1. Function to write logs into a file
#-----------------------------------------------------------------------------------------------------------------------------
def logMsg(msg_to_log,msg_type='DEBUG'):
	if msg_to_log == '':
		return 'ops_auto_error'
	import time
	global log_level
	msg_type = msg_type.upper()
	if not(log_level == 0 and msg_type != 'ERROR') and not(log_level == 1 and msg_type == 'DEBUG'):
		formatted_msg = str(time.strftime('%Y-%m-%d %H:%M:%S')) + ' - ' + str(msg_type.rjust(5)) + ': ' + str(msg_to_log)
		f = open(logfile,'a')
		f.write(formatted_msg + "\n")
		f.close()
	return 'OK'
#-----------------------------------------------------------------------------------------------------------------------------
# 2. Function to execute any command
#-----------------------------------------------------------------------------------------------------------------------------
def executeCommand(command_to_execute,cli_options=['NA']):
    logMsg('executeCommand(command_to_execute)','DEBUG')
    varValidate('string','command_to_execute',command_to_execute)
    varValidate('list','cli_options',cli_options)
    import subprocess, time
    try:
        return_text = ''
	sub = subprocess.Popen(command_to_execute,stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True,universal_newlines=True)
	if cli_options != ['NA']:
	    for cli_option in cli_options:
		logMsg('Entering option: ' + str(cli_option),'DEBUG')
		sub.stdin.write(str(cli_option) + '\n')
		sub.stdin.flush()
		time.sleep(1)
	sub_out, sub_err = sub.communicate()
	if sub_err:
	    logMsg('Popen execution failed: ' + str(sub_err),'ERROR')
	    return 'ops_auto_error'
	return_text = str(sub_out)
	return_text = return_text.strip()
	logMsg('Output of ' + str(command_to_execute) + ' : ' + str(return_text) + "\n\n",'INFO')
	return return_text
    except Exception as e:
	logMsg('Command execution failed: ' + str(e),'ERROR')
	return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 3. Function to validate variables
#-----------------------------------------------------------------------------------------------------------------------------
def varValidate(variable_type,variable_name,variable_value):
    logMsg("(varValidate(variable_type,variable_name,variable_value)","DEBUG")
    if variable_type == 'number' and not isinstance(variable_value,int):
	logMsg('Expected number in: ' + str(variable_name),'ERROR')
	exit(1)
    elif variable_type == 'string' and not isinstance(variable_value,str):
	logMsg('Expected string in: ' + str(variable_name),'ERROR')
	exit(1)
    elif variable_type == 'list' and not isinstance(variable_value,list):
	logMsg('Expected list in: ' + str(variable_name),'ERROR')
	exit(1)
    elif variable_type == 'dict' and not isinstance(variable_value,dict):
	logMsg('Expected dictionary in: ' + str(variable_name),'ERROR')
	exit(1)
    if (isinstance(variable_value,list) and (variable_value == [] or variable_value == [''])) or variable_value == '':
	logMsg('Found null value in: ' + str(variable_name),'ERROR')
	exit(1)
    if variable_name == 'connection_strings':
	local_value = variable_value[:]
	local_value[2] = 'xxxxxxxx'
    else:
	local_value = variable_value
	logMsg(str(variable_name) + ' = ' + str(local_value),'DEBUG')
    return 'OK'
#-----------------------------------------------------------------------------------------------------------------------------
# 4. Function to write outputs into a file
#-----------------------------------------------------------------------------------------------------------------------------
def writeFile(file_name,content_to_write):
	import time
	logMsg("writeFile(file_name,content_to_write)","DEBUG")
        varValidate('string','file_name',file_name)
        varValidate('string','content_to_write',content_to_write)
	f=open(file_name,'a')
	formatted_output = str(content_to_write)
        f.write(formatted_output + "\n")
        f.close()
        return 'OK'
#-----------------------------------------------------------------------------------------------------------------------------
# 5. Function to get the desired rows 
#-----------------------------------------------------------------------------------------------------------------------------
def getRows(input_text,from_line,to_line=0):
	logMsg('getRows(input_text,from_line,to_line=0)')
	varValidate('string','input_text',input_text)
	varValidate('number','from_line',from_line)
	varValidate('number','to_line',to_line)
	try:
		return_text = ''
		lines_in_text = input_text.splitlines()
		if to_line == 0:
			return_text = lines_in_text[from_line:]
		else:
			return_text = lines_in_text[from_line:to_line]
		return_text = '\n'.join(return_text)
		return_text = return_text.strip()
		return return_text
	except Exception as e:
		logMsg('Get rows failed:\n' + str(e),'ERROR')
		return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 6. Function to get the desired columns of a text
#-----------------------------------------------------------------------------------------------------------------------------
def getColumns(input_text,column_numbers,delimiter='NA'):
	logMsg('getColumns(input_text,column_numbers,delimiter=\'NA\')')
	varValidate('string','input_text',input_text)
	varValidate('list','column_numbers',column_numbers)
	varValidate('string','delimiter',delimiter)
	try:
		return_text = ''
		lines_in_text = input_text.splitlines()
		for line_in_text in lines_in_text:
			if line_in_text:
				line_in_text = line_in_text.strip()
				if delimiter == 'NA':
					words_in_text = list(line_in_text)
				else:
					words_in_text = line_in_text.split(delimiter)
				if words_in_text:
					logMsg('After delimiting: ' + str(words_in_text),"DEBUG")
					column_text = ''
					for column_number in column_numbers:
						if column_number != '' and column_number < len(words_in_text):
							column_text = column_text+words_in_text[column_number] + ' '
						else:
							logMsg('Column num ' + str(column_number) + ' out of boundary in: ' + str(words_in_text),'WARN')
					return_text = return_text + str(column_text.strip()) + '\n'
		return_text = return_text.strip()
		logMsg('Columns ' + str(column_numbers) + ':\n' + str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Get columns failed:\n' + str(e),'ERROR')
		return 'ops_auto_error'
# ----------------------------------------------------------------------------------------------------------------------------
# 6. Function to remove specific Patterns from the text
#-----------------------------------------------------------------------------------------------------------------------------
def removePatterns(input_text,patterns_to_remove,starts_with_pattern='no'):
	logMsg('removePatterns(input_text,patterns_to_remove,starts_with_pattern=\'no\')')
	varValidate('string','input_text',input_text)
	varValidate('list','patterns_to_remove',patterns_to_remove)
	varValidate('string','starts_with_pattern',starts_with_pattern)
	try:
		return_text = input_text
		for pattern_to_remove in patterns_to_remove:
			if pattern_to_remove:
				lines_in_text = return_text.splitlines()
				return_text = ''
				for line_in_text in lines_in_text:
					if line_in_text:
						line_in_text = line_in_text.strip()
						if (starts_with_pattern == 'no' and pattern_to_remove not in line_in_text) or (starts_with_pattern != 'no' and not line_in_text.startswith(pattern_to_remove)):
							return_text = return_text+str(line_in_text) + '\n'
		return_text = return_text.strip()
		logMsg('Lines without ' + str(patterns_to_remove) + ':\n' + str(return_text),'INFO')
		return return_text
	except Exception as e:
		logMsg('Remove pattern failed:\n' + str(e),'ERROR')
		return 'ops_auto_error'
# 7. Function to remove lines before first occurence of a string
#------------------------------------------------------------------------------------------------
def removeSubString(input_string, remove_until_string):
    logMsg("removeSubString(input_string, remove_until_string)","DEBUG")
    varValidate('string','input_string',input_string)
    varValidate('string','remove_until_string',remove_until_string)
    try:
        substring_to_remove =""
        input_list = input_string.split("\n")
        for line in input_list:
            if not line.startswith(remove_until_string):
                substring_to_remove = substring_to_remove + str(line) + "\n"
            else:
                break
        logMsg("String to be removed :\n" + str(substring_to_remove),"DEBUG")
        required_string = input_string.replace(substring_to_remove,'')
        logMsg("Required_string is :\n" + str(required_string))
        return required_string
    except Exception as e:
        logMsg("Remove Sub String failed" + str(e),"ERROR")
        return 'ops_auto_error'
#------------------------------------------------------------------------------------------------
# 8. Function to create a dictionary by removing first 'n' lines
#---------------------------------------------------------------------------------------------
def createDictionary(input_text,lines_to_remove,delimiter):
	logMsg("createDictionary(input_text,lines_to_remove,delimiter)","INFO")
	varValidate('string','input_text',input_text)
	varValidate('number','lines_to_remove',lines_to_remove)
	varValidate('string','delimiter',delimiter)
	try:
		output_txt = getRows(input_text,lines_to_remove)
		output_list = output_txt.split("\n\n")
		op_dic_list = []
		for output_block in output_list:
			d = {}
			for output_line in output_block.splitlines():
				if ":" in output_line and output_line.count(":")>1:
					k,v = output_line.lstrip().split(delimiter,1)
					d[k.strip()] = v.lstrip()
				elif ":" in output_line and output_line.count(":")==1:
					modified_output_line = output_line.replace(":", " : ")
					k,v = modified_output_line.lstrip().split(delimiter)
					d[k.strip()] = v.lstrip()
        		op_dic_list.append(d)
    		return op_dic_list
	except Exception as e:
		logMsg('Create Dictionary Failed : ' + str(e),'ERROR')
		return 'ops_auto_error'
#---------------------------------------------------------------------------------------------
# Function to execute multiple commands in one ssh on unix machine
#---------------------------------------------------------------------------------------------
def executeSSHCommand(commands_to_execute,command_separator=';',ssh_server='NA'):
	logMsg("executeSSHCommand(commands_to_execute,command_separator=';',ssh_server='NA')","DEBUG")
	varValidate('list','commands_to_execute',commands_to_execute)
	varValidate('string','command_separator',command_separator)
	varValidate('string','ssh_server',ssh_server)
	import subprocess
        try:
                cmd_outputs = []
                echo_separator = ' '+command_separator+' echo command_result_separator '+command_separator+' '
                final_command = echo_separator.join(command_to_execute for command_to_execute in commands_to_execute)
                if ssh_server != 'NA':
                        final_command = "ssh -q " + ssh_server + " \"" + final_command + "\""
                logMsg('Commands to execute:\n\n' + str(final_command) + "\n\n","INFO")
                sub = subprocess.Popen(final_command ,stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True,universal_newlines=True)
                sub_out, sub_err = sub.communicate()
		logMsg("Raw Output of the above command is :\n\n" + str(sub_out),"DEBUG")
                if sub_err and "Device(s) not found." not in sub_err and "/gns/software/infra/cpe/storage/gssantool/gssantool-prod/gssantool: No such file or directory" not in sub_err:
			# "Device(s) not found." string will come in sub_err when there is no device attached for powerpath hence ignoring this
			#/gns/software/infra/cpe/storage/gssantool/gssantool-prod/gssantool: No such file or directory this error comes when there is no multipath attached hence ignoring this
                        logMsg('Popen execution failed:\n'+str(sub_err),"ERROR")
                        return 'ops_auto_error'
                cmd_outputs = sub_out.split('command_result_separator')
                cmd_outputs = [cmd_out.strip() for cmd_out in cmd_outputs]
                i = 0
                for cmd in commands_to_execute:
                        logMsg("The output of " + str(cmd) + " is : \n\n" + str(cmd_outputs[i]) + "\n\n" , "INFO")
                        i = i + 1
                return cmd_outputs
        except Exception as e:
                logMsg('Execute SSH Command failed! : ' + str(e),"ERROR")
                return 'ops_auto_error'

#---------------------------------------------------------------------------------------------
# 3.Function to find a specific pattern from the string
#---------------------------------------------------------------------------------------------
def findPatterns(input_text,patterns_to_find,starts_with_pattern='no'):
        logMsg('findPatterns(input_text,patterns_to_find,starts_with_pattern=\'no\')')
        varValidate('string','input_text',input_text)
        varValidate('list','patterns_to_find',patterns_to_find)
        varValidate('string','starts_with_pattern',starts_with_pattern)
        try:
                return_text = ''
                lines_in_text = input_text.splitlines()
                for pattern_to_find in patterns_to_find:
                        if pattern_to_find:
                                for line_in_text in lines_in_text:
                                        if line_in_text:
                                                line_in_text = line_in_text.strip()
                                                if (starts_with_pattern == 'no' and pattern_to_find in line_in_text) or (starts_with_pattern != 'no' and line_in_text.startswith(pattern_to_find)):
                                                        return_text = return_text+str(line_in_text)+'\n'
                return_text = return_text.strip()
                logMsg('Lines with '+str(patterns_to_find)+':\n'+str(return_text),'INFO')
                return return_text
        except Exception as e:
                logMsg('Find pattern failed:\n'+str(e),'ERROR')
                return 'ops_auto_error'
#---------------------------------------------------------------------------------------------
# 9. Function to Check Physical & Logical Status
#---------------------------------------------------------------------------------------------
def parseDellDisk(host,vdisk_stats,pdisk_stats):
	logMsg("ParseDellDisk(host, disk_stats)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','pdisk_stats',pdisk_stats)
	varValidate('string','vdisk_stats',vdisk_stats)
	global post_check
	
	try:
		if vdisk_stats == 'ops_auto_error' or pdisk_stats == 'ops_auto_error' or 'ID' not in pdisk_stats or 'ID' not in vdisk_stats :
			err_msg = "Expected output not found!"
			pdisk_msg = host.ljust(35) + "PHYSICAL-DISK".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			output_list.append(pdisk_msg)
			writeFile(outputfile,pdisk_msg)
			writeFile(errorfile,pdisk_msg)
			logMsg(msg,"INFO")
			vdisk_msg = host.ljust(35) + "VIRTUAL-DISK".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(pdisk_msg)
				print(vdisk_msg)
			output_list.append(vdisk_msg)
			logMsg(msg,"INFO")
			writeFile(outputfile,vdisk_msg)
			writeFile(errorfile,vdisk_msg)
			return 'ops_auto_error'
		# Parsing physical disk output
		p_stats=removeSubString(pdisk_stats,'ID')
		pdisk_op_dic_list = createDictionary(p_stats,0," : ")
		flag = 0
		total_pdisk = len(pdisk_op_dic_list)
		for i in range(len(pdisk_op_dic_list)):
			if not pdisk_op_dic_list[i]['Status'].startswith('Ok'):
				flag = 1
				msg = host.ljust(35) + "PHYSICAL-DISK".ljust(25) + str(total_pdisk).ljust(15) + "NOT-OK".ljust(15) + pdisk_op_dic_list[i]['Name'].ljust(30)
				logMsg(msg,"INFO")
				output_list.append(msg)
				if post_check != 1:
					print(msg)
				writeFile(outputfile,msg)
				writeFile(errorfile,msg)
		if flag==0:
			msg = host.ljust(35) + "PHYSICAL-DISK".ljust(25) + str(total_pdisk).ljust(15) + "OK".ljust(15)
			output_list.append(msg)
			if post_check != 1:
				print(msg)
			logMsg(msg,"INFO")
			writeFile(outputfile,msg)
		# Parsing virtual disk output
		v_stats = removeSubString(vdisk_stats,'ID')
	        vdisk_op_dic_list = createDictionary(v_stats,0," : ")
		total_vdisk = len(vdisk_op_dic_list)
        	flag = 0
	        for i in range(len(vdisk_op_dic_list)):
        	        if not vdisk_op_dic_list[i]['Status'].startswith('Ok') or vdisk_op_dic_list[i]['State'] != 'Ready':
                	        flag = 1
                        	msg = host.ljust(35) + "VIRTUAL-DISK".ljust(25) + str(total_vdisk).ljust(15) + "NOT-OK".ljust(15) + str(vdisk_op_dic_list[i]['Name']).ljust(30)
				output_list.append(msg)
				if post_check != 1:
		                        print(msg)
				logMsg(msg,"INFO")
        	                writeFile(outputfile,msg)
				writeFile(errorfile,msg)
	        if flag==0:
        	        msg = host.ljust(35) + "VIRTUAL-DISK".ljust(25) + str(total_vdisk).ljust(15) + "OK".ljust(15)
			if post_check != 1:
	                	print(msg)
			logMsg(msg,"INFO")
			output_list.append(msg)
                	writeFile(outputfile,msg)
	except Exception as e:
		logMsg("Parse Dell Disk Failed : " + str(e),"ERROR")
		return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 10. Function to check HP Physical and Logical disk 
#-----------------------------------------------------------------------------------------------------------------------------
def parseHPDisk(host,disk_stats):
	logMsg("parseHPDisk(host,disk_stats)",'DEBUG')
	varValidate('string','host',host)
	varValidate('string','disk_stats',disk_stats)
	global post_check
	try:
		if disk_stats=='ops_auto_error' or disk_stats=='' or 'may not support' in disk_stats:
			err_msg = "Expected output not found!"
			pdisk_msg = host.ljust(35) + "PHYSICAL-DISK".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			output_list.append(pdisk_msg)
			writeFile(outputfile,pdisk_msg)
			writeFile(errorfile,pdisk_msg)
			logMsg(pdisk_msg,"INFO")
			vdisk_msg = host.ljust(35) + "VIRTUAL-DISK".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(vdisk_msg)
				print(pdisk_msg)
			output_list.append(vdisk_msg)
			writeFile(errorfile,vdisk_msg)
			logMsg(vdisk_msg,"INFO")
			writeFile(outputfile,vdisk_msg)
			return 'ops_auto_error'
		disk_op_list = disk_stats.split("\n")
		pdrive = []
		ldrive = []
		for i in range(len(disk_op_list)):
			if 'logicaldrive' in disk_op_list[i]:
				ldrive.append(disk_op_list[i].strip())
			elif 'physicaldrive' in disk_op_list[i]:
        			pdrive.append(disk_op_list[i].strip())
		# Parsing physical disk output
		flag = 0
		for i in range(len(pdrive)):
			if not('OK' in pdrive[i] and 'NOT OK' not in pdrive[i]):
				flag = 1
				msg = host.ljust(35) + "PHYSICAL-DISK".ljust(25) + str(len(pdrive)).ljust(15) + "NOT-OK".ljust(15) + str(pdrive[i]).ljust(30)
				output_list.append(msg)
				logMsg(msg,"INFO")
				writeFile(outputfile,msg)
				writeFile(errorfile,msg)
				if post_check != 1:
					print(msg)
		if flag==0:
			msg = host.ljust(35) + "PHYSICAL-DISK".ljust(25) + str(len(pdrive)).ljust(15) + "OK".ljust(15)
			output_list.append(msg)
			if post_check != 1:
				print(msg)
			logMsg(msg,"INFO")
			writeFile(outputfile,msg)
		# Parsing virtual disk output
		flag1 = 0
		for i in range(len(ldrive)):
                        if not('OK' in ldrive[i] and 'NOT OK' not in ldrive[i]):
                                flag1 = 1
                                msg = host.ljust(35) + "VIRTUAL-DISK".ljust(25) + str(len(ldrive)).ljust(15) + "NOT-OK".ljust(15) + str(ldrive[i]).ljust(30)
				logMsg(msg,"INFO")
				output_list.append(msg)
				writeFile(outputfile,msg)
				writeFile(errorfile,msg)
				if post_check != 1:
	                                print(msg)
                if flag1==0:
                        msg = host.ljust(35) + "VIRTUAL-DISK".ljust(25) + str(len(ldrive)).ljust(15) + "OK".ljust(15)
			output_list.append(msg)
			logMsg(msg,"INFO")
			writeFile(outputfile,msg)
			if post_check != 1:
	                        print(msg)
		
	except Exception as e:
		logMsg("Parse HP Disk failed! : " + str(e),"ERROR")
		return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 11. Function to Check Dell Battery and Storage details
#-----------------------------------------------------------------------------------------------------------------------------
def parseDellStorageAndBattery(host,storage_stats,battery_stats):
	logMsg("parseDellStorageAndBattery(host,storage_stats,battery_stats)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','storage_stats',storage_stats)
	varValidate('string','battery_stats',battery_stats)
	global post_check
	try:
		if storage_stats=='ops_auto_error' or battery_stats=='ops_auto_error' or 'ID' not in storage_stats or 'ID' not in battery_stats:
			err_msg = "Expected output not found!"
			storage_msg = host.ljust(35) + "STORAGE-CONTROLLER".ljust(25) + "-".ljust(15)+ "NOT-OK".ljust(15) + err_msg.ljust(30)
			output_list.append(storage_msg)
			writeFile(outputfile,storage_msg)
			writeFile(errorfile,storage_msg)
			logMsg(storage_msg,"INFO")
			battery_msg = host.ljust(35) + "STORAGE-BATTERY".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			writeFile(outputfile,battery_msg)
			output_list.append(battery_msg)
			writeFile(errorfile,battery_msg)
			logMsg(battery_msg,"INFO")
			if post_check != 1:
				print(storage_msg)
				print(battery_msg)
			return 'ops_auto_error'
		#Parsing the output for the storage Controller output
		storage_op = removeSubString(storage_stats,'ID')
		storage_stats_dic_list = createDictionary(storage_op,0," : ")
		total_storage = len(storage_stats_dic_list)
		flag = 0
        	for i in range(len(storage_stats_dic_list)):
			if 'ID' in storage_stats_dic_list[i].keys():
	                	if not storage_stats_dic_list[i]['Status'].startswith('Ok') or storage_stats_dic_list[i]['State']!='Ready':
        	                	flag = 1
	        	                msg = host.ljust(35) + "STORAGE-CONTROLLER".ljust(25) + str(total_storage).ljust(15) + "NOT-OK".ljust(15) + storage_stats_dic_list[i]['Name'].ljust(30)
					output_list.append(msg)
					if post_check != 1:
	        	                	print(msg)
					logMsg(msg,"INFO")
        	        	        writeFile(outputfile,msg)
					writeFile(errorfile,msg)
	        if flag==0:
        	        msg = host.ljust(35) + "STORAGE-CONTROLLER".ljust(25) + str(total_storage).ljust(15)+ "OK".ljust(15)
			if post_check != 1:
	                	print(msg)
			logMsg(msg,"INFO")
			output_list.append(msg)
	                writeFile(outputfile,msg)
		#Parsing the output for the storage battery output
		battery_op = removeSubString(battery_stats,'ID')
		battery_stats_dic_list = createDictionary(battery_op,0,":")
		total_battery = len(battery_stats_dic_list)
		flag = 0
		for i in range(len(battery_stats_dic_list)):
			if not battery_stats_dic_list[i]['Status'].startswith('Ok') or battery_stats_dic_list[i]['State']!='Ready':
				flag = 1
				msg = host.ljust(35) + "STORAGE-BATTERY".ljust(25) + str(total_battery).ljust(15)+ "NOT-OK".ljust(15) + battery_stats_dic_list[i]['Name'].ljust(30)
				output_list.append(msg)
				if post_check != 1:
					print(msg)
				logMsg(msg,"INFO")
				writeFile(outputfile,msg)
				writeFile(errorfile,msg)
		if flag==0:
			msg = host.ljust(35) + "STORAGE-BATTERY".ljust(25) + str(total_battery).ljust(15) + "OK".ljust(15)
			if post_check != 1:
				print(msg)
			logMsg(msg,"INFO")
			output_list.append(msg)
			writeFile(outputfile,msg)
	except Exception as e:
		logMsg("Parse Dell Storage and Battery  Failed : " + str(e),"ERROR")
                return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 12. Function to check HP Storage Controller and Battery 
#-----------------------------------------------------------------------------------------------------------------------------
def parseHPStorageAndBattery(host, storage_battery_stats):
	logMsg("parseHPStorageAndBattery(host,storage_battery_stats)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','storage_battery_stats',storage_battery_stats)
	global post_check
	try:
		if storage_battery_stats == 'ops_auto_error' or storage_battery_stats == '' or 'may not support' in storage_battery_stats:
			err_msg = "Expected output not found!"
			battery_msg = host.ljust(35) + "STORAGE-CONTROLLER".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(battery_msg)
			output_list.append(battery_msg)
			logMsg(battery_msg,"INFO")
			writeFile(outputfile,battery_msg)
			writeFile(errorfile,battery_msg)
			return 'ops_auto_error'
		slot_name = storage_battery_stats.splitlines()[0]
		storage_battery_op = removeSubString(storage_battery_stats,'Controller Status')
		storage_op_dic_list = createDictionary(storage_battery_op,0,":")
		flag = 0
		for i in range(len(storage_op_dic_list)):
			if "Battery/Capacitor Status" in storage_op_dic_list[i].keys():
				keyword = "Battery/Capacitor Status"
			if "Battery Status" in storage_op_dic_list[i].keys():
				keyword = "Battery Status"
			if not(storage_op_dic_list[i]['Controller Status'].startswith('OK') and storage_op_dic_list[i]['Cache Status'].startswith('OK') and storage_op_dic_list[i][keyword].startswith('OK')):
				flag = 1
				msg = host.ljust(35) + "STORAGE-CONTROLLER".ljust(25) + str(len(storage_op_dic_list)).ljust(15) + "NOT-OK".ljust(15) + slot_name.ljust(30)
				output_list.append(msg)
				if post_check != 1:
					print(msg)
				logMsg(msg,"INFO")
				writeFile(outputfile,msg)
				writeFile(errorfile,msg)
		if flag==0:
			msg = host.ljust(35) + "STORAGE-CONTROLLER".ljust(25) + str(len(storage_op_dic_list)).ljust(15) + "OK".ljust(15)
			if post_check != 1:
				print(msg)
			logMsg(msg,"INFO")
			output_list.append(msg)
			writeFile(outputfile,msg)
	except Exception as e:
		logMsg("Parse HP Storage and Battery failed : " + str(e),"ERROR")
		return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 13. Function to Check Dell Memory Status
#-----------------------------------------------------------------------------------------------------------------------------
def parseDellMemory(host,memory_stats):
	logMsg("parseDellMemory(host,memory_stats)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','memory_stats',memory_stats)
	global post_check
	try:
		import re
		if memory_stats=='ops_auto_error' or memory_stats=='' or "Index" not in memory_stats:
			err_msg = "Expected output not found!"
			mem_msg = host.ljust(35) + "MEMORY".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(mem_msg)
			output_list.append(mem_msg)
			writeFile(outputfile,mem_msg)
			writeFile(errorfile,mem_msg)
			logMsg(mem_msg,"INFO")
			return 'ops_auto_error'
		mem_capacity = re.search("Total Installed Capacity.*",memory_stats)
		memory_capacity = int( mem_capacity.group(0).split(":")[1].split()[0])
		memory_capacity = memory_capacity /1024
		memory_capacity = str(memory_capacity) + "GB"
		flag = 0
		mem_op = removeSubString(memory_stats,"Index")
		mem_op_dic_list = createDictionary(mem_op,0,":")
		i = 0
		for i in range(len(mem_op_dic_list)):
			if mem_op_dic_list[i]['Size']!='' and mem_op_dic_list[i]['Connector Name']!='':
				if not mem_op_dic_list[i]['Status'].startswith('Ok'):
					flag = 1
					msg = host.ljust(35) + "MEMORY".ljust(25) + str(memory_capacity).ljust(15) +  "NOT-OK".ljust(15) + mem_op_dic_list[i]['Connector Name'].ljust(30)
					output_list.append(msg)
					if post_check != 1:
						print(msg)
					writeFile(outputfile,msg)
					writeFile(errorfile,msg)
					logMsg(msg,"INFO")
		if flag==0:
    			msg = host.ljust(35) + "MEMORY".ljust(25) + str(memory_capacity).ljust(15) + "OK".ljust(15)
			output_list.append(msg)
			if post_check != 1:
				print(msg)
			writeFile(outputfile,msg)
			logMsg(msg,"INFO")
	except Exception as e:
		logMsg("Parse Dell Memory Failed : " + str(e),"ERROR")
                return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 14. Function to check HP Memory
#----------------------------------------------------------------------------------------------------------------------------
def parseHPMemory(host,memory_stats):
	logMsg("parseHPMemory(host,memory_stats)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','memory_stats',memory_stats)
	global post_check
	try:
		if memory_stats=='ops_auto_error' or memory_stats=='' or 'may not support' in memory_stats or ('Processor #' not in memory_stats and 'Cartridge #' not in memory_stats):
			err_msg = "Expected output not found!"
			mem_msg = host.ljust(35) + "MEMORY".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(mem_msg)
			output_list.append(mem_msg)
			writeFile(outputfile,mem_msg)
			writeFile(errorfile,mem_msg)
			logMsg(mem_msg,"INFO")
			return 'ops_auto_error'
		if "Processor" in memory_stats:
			keyword_to_look = "Processor #"
		if "Cartridge" in memory_stats:
			keyword_to_look = "Cartridge #"
		mem_stats = removeSubString(memory_stats,keyword_to_look)
		mem_op_dic_list = createDictionary(mem_stats,0,":")
		i = 0
		flag = 0
		size_of_a_module = mem_op_dic_list[1]['Size']
		size = size_of_a_module.split()[0]
		size_in_gb = int(size) / 1024
		mem_capacity = len(mem_op_dic_list) * size_in_gb
		memory_capacity = str(mem_capacity) + "GB"
		for i in range(len(mem_op_dic_list)):
			if not mem_op_dic_list[i]['Status'].startswith('Ok'):
				flag = 1
				msg = host.ljust(35) + "MEMORY".ljust(25) + str(memory_capacity).ljust(15) + "NOT-OK".ljust(15) + "Processor :" + mem_op_dic_list[i][keyword_to_look].ljust(30)
				output_list.append(msg)
				if post_check != 1:
					print(msg)
				logMsg(msg,"INFO")
				writeFile(outputfile,msg)
				writeFile(errorfile,msg)
                if flag==0:
                        msg = host.ljust(35) + "MEMORY".ljust(25) + str(memory_capacity).ljust(15) + "OK".ljust(15)
			output_list.append(msg)
			if post_check != 1:
	                        print(msg)
			logMsg(msg,"INFO")
                        writeFile(outputfile,msg)
				
	except Exception as e:
		logMsg("Parse HP Memory failed : " + str(e),"ERROR")
		return 'ops_auto_error'
#----------------------------------------------------------------------------------------------------------------------------
# 15. Function to Check CPU Details and Status
#-----------------------------------------------------------------------------------------------------------------------------
def parseDellCPU(host,cpu_stats):
	logMsg("parseDellCPU(host,cpu_stats)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','cpu_stats',cpu_stats)
	global post_check
	try:
		if cpu_stats=='ops_auto_error' or cpu_stats=='' or 'may not support' in cpu_stats or 'Index' not in cpu_stats:
			err_msg = "Expected output not found!"
			cpu_msg = host.ljust(35) + "CPU".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(cpu_msg)
			output_list.append(cpu_msg)
			writeFile(outputfile,cpu_msg)
			writeFile(errorfile,cpu_msg)
			logMsg(cpu_msg,"INFO")
			return 'ops_auto_error'
		health = {}
		cpu_health = cpu_stats.splitlines()[2]
		if ":" in cpu_health:
			k,v = cpu_health.lstrip().split(":")
			health[k.strip()] = v.lstrip()
		cpu_op = removeSubString(cpu_stats,'Index')
		cpu_op_dic_list = createDictionary(cpu_op,0," : ")
		total_core = 0
		for i in range(len(cpu_op_dic_list)):
			total_core = total_core + int(cpu_op_dic_list[i]['Core Count'])
		total_core = str(total_core) + "core"
		flag = 0
		for i in range(len(cpu_op_dic_list)):
			if cpu_op_dic_list[i]['Connector Name']!='':
				if not cpu_op_dic_list[i]['Status'].startswith('Ok'):
					flag = 1
					msg = host.ljust(35) + "CPU".ljust(25) + str(total_core).ljust(15) + "NOT-OK".ljust(15) + cpu_op_dic_list[i]['Connector Name'].ljust(30)
					output_list.append(msg)
					logMsg(msg,"INFO")
					if post_check != 1:
						print(msg)
					writeFile(outputfile,msg)
					writeFile(errorfile,msg)
	        if flag==0 and health['Health']=='Ok':
        	        msg = host.ljust(35) + "CPU".ljust(25) + str(total_core).ljust(15) + "OK".ljust(15)
			output_list.append(msg)
			if post_check != 1:
				print(msg)
			logMsg(msg,"INFO")
			writeFile(outputfile,msg)
	except Exception as e:
		logMsg("Parse Dell CPU Failed : " + str(e),"ERROR")
                return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 16. Function to check HP CPU
#-----------------------------------------------------------------------------------------------------------------------------
def parseHPCPU(host,cpu_stats):
	logMsg("parseHPCPU(host,cpu_stats)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','cpu_stats',cpu_stats)
	global post_check
	try:
		import re
		if cpu_stats=='ops_auto_error' or cpu_stats=='' or 'may not support' in cpu_stats or 'Processor' not in cpu_stats:
			err_msg = "Expected output not found!"
			cpu_msg = host.ljust(35) + "CPU".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(cpu_msg)
			output_list.append(cpu_msg)
			logMsg(cpu_msg,"INFO")
			writeFile(outputfile,cpu_msg)
			writeFile(errorfile,cpu_msg)
			return 'ops_auto_error'
		output_txt = getRows(cpu_stats,0,-5)
		op_txt = removeSubString(output_txt,'Processor')
		if 'Core' in op_txt:
			keyword = 'Core'
		else:
			keyword = 'Processor'
		cpu_op_dic_list = createDictionary(op_txt,0,":")
		flag = 0
		i = 0
		total_count = 0
		for i in range(len(cpu_op_dic_list)):
			total_count = total_count + int(cpu_op_dic_list[i][keyword])
		total_count = str(total_count)
		for i in range(len(cpu_op_dic_list)):
			if not cpu_op_dic_list[i]['Status'].startswith('Ok'):
				flag = 1
                                msg = host.ljust(35) + "CPU".ljust(25) + total_count.ljust(15) + "NOT-OK".ljust(15) +  "Processor :" + cpu_op_dic_list[i]['Processor'].ljust(30)
				output_list.append(msg)
				if post_check != 1:
	                                print(msg)
				logMsg(msg,"INFO")
                                writeFile(outputfile,msg)
				writeFile(errorfile,msg)
		if flag==0:
			msg = host.ljust(35) + "CPU".ljust(25) + total_count.ljust(15) + "OK".ljust(15)
			output_list.append(msg)
			if post_check != 1:
	                        print(msg)
			logMsg(msg,"INFO")
                        writeFile(outputfile,msg)
	except Exception as e:
		logMsg("Parse HP CPU failed : " + str(e),"ERROR")
		return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 17. Function to Check Fans Details and Status
#-----------------------------------------------------------------------------------------------------------------------------
def parseDellFan(host,fan_stats):
	logMsg("parseDellFan(host,fan_stats)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','fan_stats',fan_stats)
	global post_check
	try:
		if fan_stats=='ops_auto_error' or fan_stats=='' or 'may not support' in fan_stats or 'Index' not in fan_stats:
			err_msg = "Expected output not found!"
			fan_msg = host.ljust(35) + "FAN".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(fan_msg)
			output_list.append(fan_msg)
			logMsg(fan_msg,"INFO")
			writeFile(outputfile,fan_msg)
			writeFile(errorfile,fan_msg)
			return 'ops_auto_error'
		fan_op = removeSubString(fan_stats,'Index')
		fan_op_dic_list = createDictionary(fan_op,0," : ")
		fan_count = len(fan_op_dic_list)
		flag = 0
		for i in range(len(fan_op_dic_list)):
			if not fan_op_dic_list[i]['Status'].startswith('Ok'):
				flag = 1
				msg = host.ljust(35) + "FAN".ljust(25) + str(fan_count).ljust(15) + "NOT-OK".ljust(15) + fan_op_dic_list[i]['Probe Name'].ljust(30)
				output_list.append(msg)
				if post_check != 1:
					print(msg)
				logMsg(msg,"INFO")
				writeFile(outputfile,msg)
				writeFile(errorfile,msg)
	        if flag==0:
        	        msg = host.ljust(35) + "FAN".ljust(25) + str(fan_count).ljust(15) + "OK".ljust(15)
			output_list.append(msg)
			if post_check != 1:
	                	print(msg)
			logMsg(msg,"INFO")
	                writeFile(outputfile,msg)
	except Exception as e:
		logMsg("Parse Dell Fan Failed : " + str(e),"ERROR")
                return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 18. Function to Check HP Fans Details and Status
#-----------------------------------------------------------------------------------------------------------------------------
def parseHPFan(host,fan_stats):
	logMsg("parseHPFan(host,fan_stats)","DEBUG")
        varValidate('string','host',host)
	varValidate('string','fan_stats',fan_stats)
	global post_check
	import re
        try:
		if fan_stats=='ops_auto_error' or fan_stats=='' or 'may not support' in fan_stats:
			err_msg = "Expected output not found!"
			fan_msg = host.ljust(35) + "FAN".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(fan_msg)
			output_list.append(fan_msg)
			logMsg(fan_msg,"INFO")
			writeFile(outputfile,fan_msg)
			writeFile(errorfile,fan_msg)
			return 'ops_auto_error'
		fan_op_txt = getRows(fan_stats,2)
		fan_op_list = fan_op_txt.split("\n")
		flag = 0
		for i in range(len(fan_op_list)):
			if not ((fan_op_list[i].find('Yes')>0) and (fan_op_list[i].find('NORMAL')>0) and (fan_op_list[i].find('Yes') < fan_op_list[i].find('NORMAL'))):
				flag = 1
				match = re.search(r'#\d+',fan_op_list[i])
				flag_index = match.group()
				msg = host.ljust(35) + "FAN".ljust(25) + str(len(fan_op_list)).ljust(15) + "NOT-OK".ljust(15) + "Fan Index: " + flag_index.ljust(30)
				output_list.append(msg)
				if post_check != 1:
					print(msg)
				logMsg(msg,"INFO")
				writeFile(outputfile,msg)
				writeFile(errorfile,msg)
		if flag==0:
			msg = host.ljust(35) + "FAN".ljust(25) + str(len(fan_op_list)).ljust(15) + "OK".ljust(15)
			output_list.append(msg)
			if post_check != 1:
				print(msg)
			logMsg(msg,"INFO")
			writeFile(outputfile,msg)
        except Exception as e:
                logMsg("Parse HP FAN failed : " + str(e),"ERROR")
                return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 19. Function to Check Dell Logs
#-----------------------------------------------------------------------------------------------------------------------------
def parseDellLogs(host,alert_log,esm_log):
	logMsg("parseDellLogs(host,alert_log,esm_log)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','alert_log',alert_log)
	varValidate('string','esm_log',esm_log)
	global post_check
	try:
		from datetime import datetime
		from datetime import timedelta
		if (alert_log == 'ops_auto_error') or (esm_log == 'ops_auto_error') or (alert_log == '') or (esm_log == '') or 'Severity' not in alert_log or 'Severity' not in esm_log :
			err_msg = "Expected output not found!"
			log_msg = host.ljust(35) + "Dell-LOGs".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) +  err_msg.ljust(30)
			if post_check != 1:
				print(log_msg)
			output_list.append(log_msg)
			writeFile(outputfile,log_msg)
			writeFile(errorfile,log_msg)
			logMsg(log_msg,"INFO")
			return 'ops_auto_error'
		# Parsing Alert-Log output
		alert_log_op = removeSubString(alert_log,'Severity')
                alert_log_op_dic_list = createDictionary(alert_log_op,0," : ")
                alert_log_flag = 0
		current_date = datetime.now()
		date_last_1_month = datetime.now() - timedelta(days=30)
                for i in range(len(alert_log_op_dic_list)):
			try:
	                        date_obtained = datetime.strptime(alert_log_op_dic_list[i]['Date and Time'],"%a %b %d %H:%M:%S %Y")
			except Exception as e:
				logMsg("Date Obtained for Dell Log has problem : " + str(e),'INFO')
				continue
			if (date_last_1_month < date_obtained < current_date) and (alert_log_op_dic_list[i]['Severity']!='Ok'):
                                alert_log_flag = 1
		# Parsing Esm-Log output
		esm_log_op = removeSubString(esm_log,'Severity')
		esm_log_op_dic_list = createDictionary(esm_log_op,0," : ")
		esm_log_flag = 0
		for i in range(len(esm_log_op_dic_list)):
			try:
				date_obtained = datetime.strptime(esm_log_op_dic_list[i]['Date and Time'],"%a %b %d %H:%M:%S %Y")
			except Exception as e:
				logMsg("Date Obtained for Dell Log has problem : " + str(e),'INFO')
				continue
			if (date_last_1_month < date_obtained < current_date) and (esm_log_op_dic_list[i]['Severity']!='Ok'):
				esm_log_flag = 1
		if alert_log_flag == 0 and esm_log_flag == 0:
			msg = host.ljust(35) + "Dell-LOGs".ljust(25) + "-".ljust(15) + "OK".ljust(15)
			output_list.append(msg)
			if post_check != 1:
				print(msg)
			logMsg(msg,"INFO")
			writeFile(outputfile,msg)
		else:
			msg = host.ljust(35) + "Dell-LOGs".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + "Check Logs Manually".ljust(30)
			output_list.append(msg)
			if post_check != 1:
				print(msg)
			logMsg(msg,"INFO")
			writeFile(outputfile,msg)
			writeFile(errorfile,msg)
        except Exception as e:
                logMsg("Parse Dell Log Failed : " + str(e),"ERROR")
                return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 20. Function to Check HP IML Logs
#-----------------------------------------------------------------------------------------------------------------------------
def parseHPLogs(host,iml_log):
	logMsg("parseHPLogs(host,iml_log)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','iml_log',iml_log)
	global post_check
	try:
		from datetime import datetime
		from datetime import timedelta
		if (iml_log=='ops_auto_error') or (iml_log=='') or 'Event' not in iml_log:
			err_msg = "Expected output not found!"
			iml_msg = host.ljust(35) + "IML-LOGs".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(iml_msg)
			output_list.append(iml_msg)
			logMsg(iml_msg,"INFO")
			writeFile(outputfile,iml_msg)
			writeFile(errorfile,iml_msg)
			return 'ops_auto_error'
		iml_log_list = iml_log.split("\n")
		event = ""
		caution = ""
		for i in range(len(iml_log_list)):
			if iml_log_list[i].startswith("Event"):
				event = event + str(iml_log_list[i]) + "\n"
			elif iml_log_list[i].startswith("CAUTION"):
				caution = caution + str(iml_log_list[i]) + "\n"
		date_str = getColumns(event,[2],": ")
		date_list = date_str.split("\n")
		current_date = datetime.now()
		date_last_2_week = datetime.now() - timedelta(days=14)
		flag = 0
		for i in range(len(date_list)):
			try:
				date_obtained = datetime.strptime(date_list[i],"%m/%d/%Y %H:%M")
			except Exception as e:
				logMsg("HP Log has some issue with date format : " + str(e),'INFO')
				continue
			if (date_last_2_week < date_obtained < current_date):
				flag = 1
				msg = host.ljust(35) + "IML-LOGs".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + "Check logs Manually".ljust(30)
				logMsg(msg,"INFO")
				output_list.append(msg)
				if post_check != 1:
					print(msg)
				writeFile(outputfile,msg)
				writeFile(errorfile,msg)
				break
		if flag==0:
			msg = host.ljust(35) + "IML-LOGs".ljust(25) + "-".ljust(15) + "OK".ljust(15)
			output_list.append(msg)
			if post_check != 1:
				print(msg)
			logMsg(msg,"INFO")
			writeFile(outputfile,msg)

	except Exception as e:
		logMsg("Parse HP Logs Failed : " + str(e),"ERROR")
		return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 21. Function to Check Dell Power Supply Status
#-----------------------------------------------------------------------------------------------------------------------------
def parseDellPowerSupply(host,power_stats):
	logMsg("parseDellPowerSupply(host,power_stats)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','power_stats',power_stats)
	global post_check
	try:
		if power_stats=='ops_auto_error' or power_stats=='' or 'Index' not in power_stats:
			err_msg = "Expected output not found!"
			power_msg = host.ljust(35) + "POWER-SUPPLY".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(power_msg)
			logMsg(power_msg,"INFO")
			output_list.append(power_msg)
			writeFile(outputfile,power_msg)
			writeFile(errorfile,power_msg)
			return 'ops_auto_error'
		power_op = removeSubString(power_stats,'Index')
		power_op_dic_list = createDictionary(power_op,0,":")
		power_count = len(power_op_dic_list)
		flag = 0
		for i in range(len(power_op_dic_list)):
			if not power_op_dic_list[i]['Status'].startswith('Ok'):
				flag = 1
				msg = host.ljust(35) + "POWER-SUPPLY".ljust(25) + str(power_count).ljust(15) + "NOT-OK".ljust(15) + power_op_dic_list[i]['Location'].ljust(30)
				output_list.append(msg)
				if post_check != 1:
					print(msg)
				logMsg(msg,"INFO")
				writeFile(outputfile,msg)
				writeFile(errorfile,msg)
		if flag==0:
			msg = host.ljust(35) + "POWER-SUPPLY".ljust(25) + str(power_count).ljust(15)+ "OK".ljust(15)
			output_list.append(msg)
			if post_check != 1:
				print(msg)
			logMsg(msg,"INFO")
			writeFile(outputfile,msg)
	except Exception as e:
                logMsg("Parse Dell Power Supply failed : " + str(e),"ERROR")
                return 'ops_auto_error'
		
#-----------------------------------------------------------------------------------------------------------------------------
# 22. Function to check HP Power Supply
#-----------------------------------------------------------------------------------------------------------------------------
def parseHPPowerSupply(host,power_stat):
	logMsg("parseHPPowerSupply(host,power_stat)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','power_stat',power_stat)
	global post_check
	try:
		if (power_stat=='ops_auto_error') or power_stat=='' or 'may not support' in power_stat:
			err_msg = "Expected output not found!"
			power_msg = host.ljust(35) + "POWER-SUPPLY".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(power_msg)
			output_list.append(power_msg)
			logMsg(power_msg,"INFO")
			writeFile(outputfile,power_msg)
			writeFile(errorfile,power_msg)
			return 'ops_auto_error'
		ps_stats = removePatterns(power_stat,["\n"])
		ps_list = ps_stats.split("\n")
		flag = 0
		for i in range(len(ps_list),6):
			if ps_list[i].startswith("Power supply"):
				j = i
				if not(( ps_list[j+i]=="Present  : Yes" ) and ( ps_list[j+3]=="Condition: Ok" )):
					flag = 1
					msg = host.ljust(35) + "POWER-SUPPLY".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + str(ps_list[i]).ljust(30)
					output_list.append(msg)
					if post_check != 1:
						print(msg)
					logMsg(msg,"INFO")
					writeFile(outputfile,msg)
					writeFile(errorfile,msg)
		if flag==0:
			msg = host.ljust(35) + "POWER-SUPPLY".ljust(25) + "-".ljust(15) + "OK".ljust(15)
			output_list.append(msg)
			if post_check != 1:
				print(msg)
			logMsg(msg,"INFO")
			writeFile(outputfile,msg)
	except Exception as e:
		logMsg("Parse HP Power Supply Failed : " + str(e),"ERROR")
                return 'ops_auto_error'
		
#-----------------------------------------------------------------------------------------------------------------------------
# 23. Function to Check HP temperature Status
#-----------------------------------------------------------------------------------------------------------------------------
def parseHPTemperature(host,temp_stats):
	logMsg("parseHPTemperature(host,temp_stats)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','temp_stats',temp_stats)
	global post_check
	try:
		if (temp_stats=='ops_auto_error') or (temp_stats=='') or 'may not support' in temp_stats:
			err_msg = "Expected output not found!"
			temp_msg = host.ljust(35) + "TEMPERATURE".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(temp_msg)
			output_list.append(temp_msg)
			logMsg(temp_msg,"INFO")
			writeFile(outputfile,temp_msg)
			writeFile(errorfile,temp_msg)
			return 'ops_auto_error'
		temp_text = getRows(temp_stats,1)
		temp_op_list = temp_text.split("\n")
		flag = 0
		for i in range(len(temp_op_list)):
			if "Normal" not in temp_op_list[i]:
				match = re.search(r'\d+',temp_op_list[i])
				temp_id = match.group()
				flag = 1
				msg = host.ljust(35) + "TEMPERATURE".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + "ID :" + temp_id.ljust(30)
				output_list.append(msg)
				if post_check != 1:
					print(msg)
				logMsg(msg,"INFO")
				writeFile(outputfile,msg)
				writeFile(errorfile,msg)
		if flag==0:
			msg = host.ljust(35) + "TEMPERATURE".ljust(25) + "-".ljust(15) + "OK".ljust(15)
			output_list.append(msg)
			if post_check != 1:
				print(msg)
			logMsg(msg,"INFO")
			writeFile(outputfile,msg)
	except Exception as e:
		logMsg("Parse HP Temp Failed : " + str(e),"ERROR")
		return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 24. Function to check Dell hardware temperature
#-----------------------------------------------------------------------------------------------------------------------------
def parseDellTemperature(host,temp_stats):
	logMsg("parseDellTemperature(host,temp_stats)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','temp_stats',temp_stats)
	global post_check
	try:
		if temp_stats=='ops_auto_error' or temp_stats=='' or 'Index' not in temp_stats:
			err_msg = "Expected output not found!"
			temp_msg = host.ljust(35) + "TEMPERATURE".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			writeFile(outputfile,temp_msg)
			if post_check != 1:
				print(temp_msg)
			output_list.append(temp_msg)
			logMsg(temp_msg,"INFO")
			writeFile(errorfile,temp_msg)
			return 'ops_auto_error'
		temp_op = removeSubString(temp_stats,'Index')
		temp_op_dic_list = createDictionary(temp_op,0,":")
		temp_count = len(temp_op_dic_list)
        	flag = 0
	        for i in range(len(temp_op_dic_list)):
			if not temp_op_dic_list[i]['Status'].startswith('Ok'):
				flag = 1
				msg = host.ljust(35) + "TEMPERATURE".ljust(25) + str(temp_count).ljust(15) + "NOT-OK".ljust(15) +  temp_op_dic_list[i]['Probe Name'].ljust(30)
				logMsg(msg,"INFO")
				output_list.append(msg)
				if post_check != 1:
					print(msg)
				writeFile(outputfile,msg)
				writeFile(errorfile,msg)
	        if flag==0:
        	        msg = host.ljust(35) + "TEMPERATURE".ljust(25) + str(temp_count).ljust(15) + "OK".ljust(15)
			output_list.append(msg)
			if post_check != 1:
	                	print(msg)
			logMsg(msg,"INFO")
	                writeFile(outputfile,msg)
	except Exception as e:
                logMsg("Parse Dell Temperature failed : " + str(e),"ERROR")
                return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 25. Function to check the status of NTPD
#-----------------------------------------------------------------------------------------------------------------------------
def parseNTP(host,ntpd_stats,ntpq_stats):
	logMsg("parseNTP(host)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','ntpd_stats',ntpd_stats)
	varValidate('string','ntpq_stats',ntpq_stats)
	global post_check
	try:
		if ntpd_stats == 'ops_auto_error' or ntpq_stats == 'ops_auto_error' or 'may not support' in ntpd_stats or 'may not support' in ntpq_stats:
			err_msg = "Expected output not found!"
			ntp_msg = host.ljust(35) + "NTP".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(ntp_msg)
			output_list.append(ntp_msg)
			writeFile(outputfile,ntp_msg)
			writeFile(errorfile,ntp_msg)
			logMsg(ntp_msg,"INFO")
			return 'ops_auto_error'
		flag1 = 0
		if 'is running' not in ntpd_stats:
			flag1 = 1
		else:
			flag1 = 0
		ntpq_op = getRows(ntpq_stats,3)
		ntpq_text = ntpq_op.split("\n")
		return_text = ""
		for i in range(len(ntpq_text)):
			text = " ".join(ntpq_text[i].split())
			return_text = return_text + text + "\n"
		server_text = getColumns(return_text,[0],' ')
		server_list = server_text.split("\n")
		offset_text = getColumns(return_text,[8],' ')
		offset_list = offset_text.split("\n")
		flag2 = 0
		for i in range(len(offset_list)):
			if not (float(offset_list[i]) < float(1)):
				flag2 = 1
		if flag1==0 and flag2==0:
			msg = host.ljust(35) + "NTP".ljust(25) + "-".ljust(15) + "OK".ljust(15)
			logMsg(msg,"INFO")
			output_list.append(msg)
			if post_check != 1:
				print(msg)
			writeFile(outputfile,msg)
		else:
			msg = host.ljust(35) + "NTP".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15)
			logMsg(msg,"INFO")
			output_list.append(msg)
			if post_check != 1:
				print(msg)
			writeFile(outputfile,msg)
			writeFile(errorfile,msg)
	except Exception as e:
                logMsg("Parse NTP status failed : " + str(e),"ERROR")
                return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 27. Function to check Nagios Agent Status
#----------------------------------------------------------------------------------------------------------------------------
def parseNagios(host,nagios_stats):
	logMsg("parseNagios(host,nagios_stats)","DEBUG")
	varValidate('string','host',host)
	varValidate('list','nagios_stats',nagios_stats)
	global post_check
	try:
		from datetime import datetime
		from datetime import timedelta
		os_type = str(nagios_stats[0])
		process_flag = 0
		log_flag = 0
		config_flag = 0
		gns_flag = 0
		package_flag = 0
		if nagios_stats == 'ops_auto_error' or nagios_stats == '' or 'may not support' in nagios_stats:
			err_msg = "Expected output not found!"
			nagios_msg = host.ljust(35) + "NAGIOS".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(nagios_msg)
			output_list.append(nagios_msg)
			logMsg(nagios_msg,"INFO")
			writeFile(outputfile,nagios_msg)
			writeFile(errorfile,nagios_msg)
			return 'ops_auto_error'
		# 1. Process Check
		if "nagios-agents.cfg" in str(nagios_stats[1]) and "nagios_service_manager.pl" in str(nagios_stats[1]):
			logMsg("Process check passed! Nagios services are running!","INFO")
			process_check = 1
		# 2. Log check
		if not "path does not exists" in str(nagios_stats[2]):
			logMsg("Performing log Checks!","INFO")
			log_path_op = str(nagios_stats[2])
			dates_obtained = getColumns(log_path_op,[0],': ')
			date_list = dates_obtained.split('\n')
			current_date = datetime.now()
			date_last_10_min = datetime.now() - timedelta(minutes=10)
			for i in range(len(date_list)):
				try:
					date_obtained = datetime.strptime(date_list[i],"%a %b %d %H:%M:%S %Y")
				except Exception as e:
					logMsg("Date Obtained for Nagios has some problem with format : " + str(e),'INFO')
					continue
				if (date_last_10_min <= date_obtained <= current_date):
					log_flag = 1
					break
		# 3. Config Check
		if (not "path does not exists" in str(nagios_stats[3]) and str(nagios_stats[3]) == "") or (not "path does not exists" in str(nagios_stats[4]) and str(nagios_stats[4]) == ""):
			logMsg("Config check Passed!",'INFO')
			config_flag = 1
		if process_check == 1 and log_flag == 1 and config_flag == 1:
			logMsg("ALl 3 checks ie. Process/ Log/ Config check passed!",'INFO')
			nagios_msg = host.ljust(35) + "NAGIOS".ljust(25) + "-".ljust(15) + "OK".ljust(15)
			if post_check != 1:
				print(nagios_msg)
			output_list.append(nagios_msg)
			logMsg(nagios_msg,"INFO")
			writeFile(outputfile,nagios_msg)
		else:
			logMsg("Either Process/ Log/ Config check failed!",'INFO')
			if "RHEL 4" in os_type:
				gns_msg = host.ljust(35) + "NAGIOS".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + "Either process/log/path check failed".ljust(30)
				writeFile(errorfile,gns_msg)
				writeFile(outputfile,gns_msg)
				if post_check != 1:
					print(gns_msg)
				output_list.append(gns_msg)
				logMsg(gns_msg,'INFO')
			if "RHEL 5" in os_type:
				logMsg("Checking additional check ie GNS and PACKAGE check for RHEL 5","INFO")
				# 4. Gns Check
				if (("path exists" in str(nagios_stats[5])) and ("path exists" in str(nagios_stats[6])) and ("path exists" in str(nagios_stats[7]))):
					logMsg("GNS Check passed!",'INFO')
					gns_flag = 1
				if "gs-esm-nagios-1.1-9" in str(nagios_stats[8]):
					logMsg("Package Check passed!",'INFO')
					package_flag = 1
				if gns_flag == 1 and package_flag == 1:
					gns_msg = host.ljust(35) + "NAGIOS".ljust(25) + "-".ljust(15) + "OK".ljust(15)
					if post_check != 1:
						print(gns_msg)
					writeFile(outputfile,gns_msg)
					output_list.append(gns_msg)
					logMsg(gns_msg,'INFO')
				elif gns_flag == 1 and package_flag == 0 :
					gns_msg = host.ljust(35) + "NAGIOS".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + "Package check failed".ljust(30)
					if post_check != 1:
						print(gns_msg)
					writeFile(errorfile,gns_msg)
					writeFile(outputfile,gns_msg)
					output_list.append(gns_msg)
					logMsg(gns_msg,'INFO')
				elif gns_flag == 0 and package_flag == 1:
					gns_msg = host.ljust(35) + "NAGIOS".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + "Gns check failed".ljust(30)
					if post_check != 1:
						print(gns_msg)
					writeFile(errorfile,gns_msg)
					writeFile(outputfile,gns_msg)
					output_list.append(gns_msg)
					logMsg(gns_msg,'INFO')
				else:
					gns_msg = host.ljust(35) + "NAGIOS".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + "Either process/log/path check failed".ljust(30)
					if post_check != 1:
						print(gns_msg)
					writeFile(errorfile,gns_msg)
					writeFile(outputfile,gns_msg)
					output_list.append(gns_msg)
					logMsg(gns_msg,'INFO')
			if "RHEL 6" in os_type:
				if (("path exists" in str(nagios_stats[5])) and ("path exists" in str(nagios_stats[6])) and ("path exists" in str(nagios_stats[7]))):
					logMsg("Checking additional check ie GNS check for RHEL 6",'INFO')
					gns_msg = host.ljust(35) + "NAGIOS".ljust(25) + "-".ljust(15) + "OK".ljust(15)
					if post_check != 1:
						print(gns_msg)
					writeFile(outputfile,gns_msg)
					output_list.append(gns_msg)
					logMsg(gns_msg,'INFO')
				else:
					gns_msg = host.ljust(35) + "NAGIOS".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + "Either process/log/path check failed".ljust(30)
					if post_check != 1:
						print(gns_msg)
					writeFile(outputfile,gns_msg)
					writeFile(errorfile,gns_msg)
					output_list.append(gns_msg)
					logMsg(gns_msg,'INFO')
	except Exception as e:
		logMsg("Parse Nagios Agent failed : " + str(e),"ERROR")		
		return 'ops_auto_error'
#----------------------------------------------------------------------------------------------------------------------------
# 28. Function to Check OS Version
#-----------------------------------------------------------------------------------------------------------------------------
def parseOSVersion(host,os_stats):
        logMsg("parseOSVersion(host,os_stats)","DEBUG")
	varValidate('string','host',host)
	varValidate('string','os_stats',os_stats)
	global post_check
	try:
		if os_stats == "ops_auto_error" or os_stats == "":
			err_msg = "Expected output not found!"
			os_msg = host.ljust(35) + "OS-Version".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(os_msg)
			output_list.append(os_msg)
			logMsg(os_msg,"INFO")
			writeFile(outputfile,os_msg)
			writeFile(errorfile,os_msg)
			return 'ops_auto_error'
		else:
			msg = host.ljust(35) + "OS-Version".ljust(25) + "-".ljust(15) + "OK".ljust(15)
			if post_check != 1:
				print(msg)
			logMsg(msg,"INFO")
			writeFile(outputfile,msg)
			output_list.append(msg)
	except Exception as e:
		logMsg("Parse OS Version Failed : " + str(e),"ERROR")
		return 'ops_auto_error'
		
#----------------------------------------------------------------------------------------------------------------------------
# 28. Function to Check CFE Status
#-----------------------------------------------------------------------------------------------------------------------------
def parseCFE(host,cfe_output):
        logMsg("parseCFE(host,cfe_output)","DEBUG")
        varValidate('string','host',host)
	varValidate('list','cfe_output',cfe_output)
	global post_check
        try:
		if cfe_output=='ops_auto_error' or cfe_output[0]=='ops_auto_error' or cfe_output[0]=='' or cfe_output[1]=='ops_auto_error' or cfe_output[1]=='':
			err_msg = "Expected output not found!"
			cfe_msg = host.ljust(35) + "CFE".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
			if post_check != 1:
				print(cfe_msg)
			output_list.append(cfe_msg)
			writeFile(outputfile,cfe_msg)
			writeFile(errorfile,cfe_msg)
			logMsg(cfe_msg,"INFO")
			return 'ops_auto_error'
		else:
			if 'mode_greenlight' in cfe_output[1]:
				msg = host.ljust(35) + "CFE".ljust(25) + "-".ljust(15) + "OK".ljust(15)
				if post_check != 1:
					print(msg)
				logMsg(msg,"INFO")
				output_list.append(msg)
				writeFile(outputfile,msg)
			else:
				cfe_op = " ".join(cfe_output[1].split())
				msg = host.ljust(35) + "CFE".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + cfe_op.ljust(30)
				if post_check != 1:
					print(msg)
				logMsg(msg,"INFO")
		                writeFile(outputfile,msg)
				writeFile(errorfile,msg)
				output_list.append(msg)
        except Exception as e:
                logMsg("Parse CFE Failed : " + str(e),"ERROR")
                return 'ops_auto_error'

#----------------------------------------------------------------------------------------------------------------------------
# 29. Function to Check DELL Hardware
#-----------------------------------------------------------------------------------------------------------------------------
def checkDellHardware(host):
	logMsg("checkDellHardware(host)","DEBUG")
	varValidate('string','host',host)
	global post_check
	error_flag=''
	try:
		dell_command_list=["/opt/dell/srvadmin/bin/omreport storage vdisk controller=0","/opt/dell/srvadmin/bin/omreport storage pdisk controller=0",
        	        "/opt/dell/srvadmin/bin/omreport storage controller","/opt/dell/srvadmin/bin/omreport storage battery",
                	"/opt/dell/srvadmin/bin/omreport chassis memory",
	                "/opt/dell/srvadmin/bin/omreport chassis processors",
        	        "/opt/dell/srvadmin/bin/omreport chassis fans",
                	"/opt/dell/srvadmin/bin/omreport system alertlog","/opt/dell/srvadmin/bin/omreport system esmlog",
	                "/opt/dell/srvadmin/bin/omreport chassis pwrsupplies",
        	        "/opt/dell/srvadmin/bin/omreport chassis temps"]
		dell_hw_op_list = executeSSHCommand(dell_command_list, ';',host)
		if dell_hw_op_list == 'ops_auto_error':
			logMsg((str(host).ljust(35) + "Expected Output Not Found","ERROR"))
			msg = host.ljust(35) + "DELL-HARDWARE".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + "Expected output not found!".ljust(30)
			if post_check != 1:
				print(msg)
			output_list.append(msg)
			writeFile(outputfile,msg)
			writeFile(errorfile,msg)
			error_flag='ops_auto_error'
		else:
			parseDellDisk(host,str(dell_hw_op_list[0]),str(dell_hw_op_list[1]))
			parseDellStorageAndBattery(host,str(dell_hw_op_list[2]),str(dell_hw_op_list[3]))
			parseDellMemory(host,str(dell_hw_op_list[4]))
			parseDellCPU(host,str(dell_hw_op_list[5]))
			parseDellFan(host,str(dell_hw_op_list[6]))
			parseDellLogs(host,str(dell_hw_op_list[7]),str(dell_hw_op_list[8]))
			parseDellPowerSupply(host,str(dell_hw_op_list[9]))
			parseDellTemperature(host,str(dell_hw_op_list[10]))
		exit_code=multiPowerMain(host)
		checkNetworkInterface(host)
		if exit_code=='OK':
			logMsg("Multipath and Powerpath is OK!","DEBUG")
		else:
			logMsg("Multipath and Powerpath is NOT-OK!","DEBUG")
		if error_flag=='ops_auto_error':
			return 'ops_auto_error'
	except Exception as e:
		logMsg("Check Dell Hardware Failed : " + str(e),'ERROR')
		return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 29. Function to Check HP Hardware
#-----------------------------------------------------------------------------------------------------------------------------
def checkHPHardware(host):
	logMsg("checkHPHardware(host)","DEBUG")
	varValidate('string','host',host)
	global post_check
	error_flag=''
	try:
		hp_command_list=["/usr/sbin/hpacucli ctrl all show config",
	                "/usr/sbin/hpacucli ctrl all show status",
        	        "/sbin/hpasmcli -s 'show dimm'",
                	"/sbin/hpasmcli -s 'show server'",
	                "/sbin/hpasmcli -s 'show fans'",
        	        "/sbin/hpasmcli -s 'show iml'",
                	"/sbin/hpasmcli -s 'show powersupply'",
	                "/sbin/hplog -t"]
		hp_hw_op_list = executeSSHCommand(hp_command_list,';',host)
		if hp_hw_op_list == 'ops_auto_error':
			logMsg((str(host).ljust(35) + "Expected Output Not Found","ERROR"))
			msg = host.ljust(35) + "HP-HARDWARE".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + "Expected output not found!".ljust(30)
			if post_check != 1:
				print(msg)
			output_list.append(msg)
			writeFile(outputfile,msg)
			writeFile(errorfile,msg)
			error_flag='ops_auto_error'
		else:
			parseHPDisk(host,str(hp_hw_op_list[0]))
			parseHPStorageAndBattery(host,str(hp_hw_op_list[1]))
			parseHPMemory(host,str(hp_hw_op_list[2]))
			parseHPCPU(host,str(hp_hw_op_list[3]))
			parseHPFan(host,str(hp_hw_op_list[4]))
			parseHPLogs(host,str(hp_hw_op_list[5]))
			parseHPPowerSupply(host,str(hp_hw_op_list[6]))
			parseHPTemperature(host,str(hp_hw_op_list[7]))
		exit_code=multiPowerMain(host)
		checkNetworkInterface(host)
		if exit_code=='OK':
			logMsg("Multipath and Powerpath is OK!","DEBUG")
		else:
			logMsg("Multipath and Powerpath is NOT-OK!","DEBUG")
		if error_flag=='ops_auto_error':
			return 'ops_auto_error'
	except Exception as e:
		logMsg("Check HP Hardware Failed! : " + str(e),'ERROR')
		return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 30. Function ot check SOftware component
#-----------------------------------------------------------------------------------------------------------------------------
def checkSoftware(host):
	logMsg("checkSoftware(host)","DEBUG")
	varValidate('string','host',host)
	global post_check
	try:
		software_cmd_list = ["ls -l /var/is2/state/allclasses","cat /var/is2/state/allclasses|grep -i light",
				"service ntpd status",
				"ntpq -p",
				"cat /etc/gs-release",
				"ps -aef|grep -i nagios|grep -v grep",
				"if [ -f \"" + str(log_path) + "\" ]; then grep -w 'connected to.*esm.services.gs.com.*' /var/log/nagios/agent.log; else echo 'path does not exists';fi",
				"if [ -f \"" + str(config1_path) + "\" ]; then cat /local/opt/nagios-agent/etc/nagios-agents.cfg |egrep -i 'stag|qa';else echo 'path does not exists';fi",
				"if [ -f \"" + str(config2_path) + "\" ]; then cat /opt/nagios-agent/etc/nagios-agents.cfg |egrep -i 'stag|qa';else echo 'path does not exists';fi",
				"if [ -f \"" + str(gns_agent_path) + "\" ]; then echo 'path exists'; else echo 'path does not exist'; fi",
				"if [ -f \"" + str(gns_perl_path) + "\" ]; then echo 'path exists'; else echo 'path does not exist'; fi",
				"if [ -f \"" + str(gns_recovery_path) + "\" ]; then echo 'path exists'; else echo 'path does not exist'; fi",
				"rpm -q gs-esm-nagios"]
		software_op_list = executeSSHCommand(software_cmd_list,';',host)
		if software_op_list == 'ops_auto_error':
			msg = host.ljust(35) + "SOFTWARE".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + "Expected output not found!".ljust(30)
			if post_check != 1:
				print(msg)
			output_list.append(msg)
			logMsg(msg,"INFO")
			writeFile(outputfile,msg)
			writeFile(errorfile,msg)
			return 'ops_auto_error'
		else:
			parseCFE(host,software_op_list[:2])
			parseNTP(host,str(software_op_list[2]),str(software_op_list[3]))
			parseOSVersion(host,str(software_op_list[4]))
			parseNagios(host,software_op_list[4:])
	except Exception as e:
		logMsg("Check Software Failed : " + str(e),"ERROR")
		return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 31. Function to check Supported Host and platform
#-----------------------------------------------------------------------------------------------------------------------------
def checkHostAndPlatform(host):
	logMsg("checkHostAndPlatform(host)","DEBUG")
	varValidate('string','host',host)
	try:
		host_type = executeCommand("invcli -v4 -h " + host + "| awk -F \":\" '{print $12}'")
		if host_type=='ops_auto_error':
			print("Invcli Command Failed!")
			return 'ops_auto_error'
		host_type = host_type.lower()
		pf = ""
		if host_type=="gs bai external".lower() or host_type=="Services Application Support (SAS)".lower():
			host_type = "supported"
			platform = executeCommand("invcli -v4 -h " + host + "| awk -F \":\" '{print $16}'")
			platform = platform.lower()
			if "dell" in platform:
				pf = 'dell'
			elif "hp" in platform:
        	                pf = 'hp'
			elif "virtual machine" in platform:
				pf = 'vm'
			else:
				pf = 'Invalid platform'
		else:
			print '\nNot Supported Host\n'
		logMsg("Host type is : " + str(host_type),'INFO')
		logMsg("Platform is : " + str(platform) ,'INFO')
		return (host_type,pf)
	except Exception as e:
		logMsg("Check Host and Platform failed : " + str(e),"ERROR")
		return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 32. Function to compare pre and post maintainence output
#-----------------------------------------------------------------------------------------------------------------------------
def checkPrePost():
	logMsg("checkPrePost()","DEBUG")
	try:
		correct_output = 0
		err_count = 0
		total_output = len(output_list)
		logMsg("Length of the current run output list is : " + str(total_output),'INFO')
		logMsg("Raw output List is :\n" + str(output_list),'INFO')
		pre_post_header = "Server Name".ljust(35) + "Component".ljust(25) + "Pre-Count".ljust(15) + "Post-Count".ljust(15) + "Pre-Status".ljust(15) + "Post-Status".ljust(15) + "Final Result".ljust(15) + "Failed component".ljust(25) 
		pre_post_margin = "======================================================================================================================================================".ljust(150)	
		# Comparing the pre output with the post output and displaying the output
		print("\n" + pre_post_header)
		print(pre_post_margin + "\n")
		logMsg(pre_post_header,"DEBUG")
		for host in host_list:
        		for output in output_list:
				logMsg(output,'INFO')
                		if output.startswith(host):
					# Extracting host, component name, count/size, status from post output.
                        		post_output = " ".join(str(output).split())
					post_output_list = post_output.split()
	                        	post_host = post_output_list[0]
	        	                post_component = post_output_list[1]
        	        	        post_count = post_output_list[2]
					post_status = post_output_list[3]
					length_of_post_output_list = len(post_output_list)
					i=4
					post_failed_comp =""
					# Extracting only Failed Component part from the output
					while (i < length_of_post_output_list):
						post_failed_comp = post_failed_comp + str(post_output_list[i]) + " "
						i = i + 1
					logMsg(post_failed_comp,"INFO")
					# Getting pre-output from the latest pre-output files.
					get_pre_output_cmd = "egrep -h  \"" + post_host + ".*" + post_component  + "\" " + logfile_directory + "*/pre_*_" + post_host + ".txt | tail -1" 
					logMsg("Command to execute is : " + str(get_pre_output_cmd),'INFO')
        	        	        pre_output = executeCommand(get_pre_output_cmd)
					pre_output_list = pre_output.split()
					logMsg(pre_output_list,'INFO')
					# Matching the hostname as well as component of pre and post outputs.
					if post_host == pre_output_list[0] and post_component == pre_output_list[1]:
						if post_status == "OK" and post_count >= pre_output_list[2]:
							pre_post_msg = post_host.ljust(35) + post_component.ljust(25) + pre_output_list[2].ljust(15) + post_count.ljust(15) + pre_output_list[3].ljust(15) + post_status.ljust(15) + "OK".ljust(15)
							print(pre_post_msg)
							logMsg(pre_post_msg,'INFO')
							logMsg(pre_post_margin,"INFO")
						else:
							pre_post_msg = post_host.ljust(35) + post_component.ljust(25) + pre_output_list[2].ljust(15) + post_count.ljust(15) + pre_output_list[3].ljust(15) + post_status.ljust(15) + "NOT-OK".ljust(15) + post_failed_comp.ljust(25)
							print(pre_post_msg)
							logMsg(pre_post_msg,'INFO')
							logMsg(pre_post_margin,"INFO")
							err_count = err_count + 1
					else:
						err_count = err_count + 1
						logMsg(err_count,"DEBUG")
		correct_output = total_output - err_count
		logMsg(correct_output,"DEBUG")
		if correct_output!=0:
        		print("\n" + str(correct_output) + " out of " + str(total_output) + " is OK")
			logMsg(str(correct_output) + " out of " + str(total_output) + " is OK","INFO")
		else:
        		print("\n" + str(correct_output) + " out of " + str(total_output) + " is OK")
			logMsg(str(correct_output) + " out of " + str(total_output) + " is OK","INFO")
	except Exception as e:
		logMsg("Check Pre Post Failed! : " + str(e),"ERROR")
		return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# 33. Function to check if a host is Pingable and SSH'able
#-----------------------------------------------------------------------------------------------------------------------------
def checkPingLogin(host):
        logMsg("checkPingLogin(host)","DEBUG")
	varValidate('string','host',host)
        try:
		ssh_check = 0
		ping_check = 0
		ping_cmd = "ping -c 2 " + host
		ssh_cmd = "ssh -q " + host + " \"uname -n\""
		ping_op = executeCommand(ping_cmd)
		#Checking if the host is pingable
		if "0% packet loss" in ping_op:
			ping_check = 1
			ssh_op = executeCommand(ssh_cmd)
			# CHecking if host is SSH'able
			if host not in ssh_op:
				print(str(host) + " is pingable but NOT SSH'able!\n")
				logMsg(str(host) + " is pingable but NOT SSH'able!","ERROR")
				return 'ops_auto_error'
			ssh_output = " ".join(str(ssh_op).split())
			if host == ssh_output:
				ssh_check = 1
			else:
				ssh_check = 0
		else:
			print(str(host) + "is NOT Pingable!\n")
			logMsg(str(host) + "is NOT Pingable!","ERROR")
		if ping_check == 1 and ssh_check == 1:
			return True 
		else:
			logMsg(str(host) + " is either NOT Pingable or NOT Online","ERROR")
			return False
        except Exception as e:
                logMsg("Check Ping Login Failed! : " + str(e),"ERROR")
                return 'ops_auto_error'
#-----------------------------------------------------------------------------------------------------------------------------
# POWERPATH AND MULTIPATH FUNCTIONS
# DESCRIPTION	: To check multipath and powerpath in a system.
# AUTHOR	: SUMIT CHAWLA
#-----------------------------------------------------------------------------------------------------------------------------
# Function to check multipath failure
#============================================================================================
def multipath(host):
	logMsg("multipath(host)","DEBUG")
	global post_check
	return_code='OK'
	total_devices="-"
	active_paths=0
	active_paths_frm_gssantool="-"
	ok_value="NOT-OK"
	luns_ok_value="NOT-OK"
	err_msg="Expected output not found!"
	luns_err_msg="Expected output not found!"
	multipath_cmd_list=["/sbin/multipath -ll",
	"/sbin/multipath -ll| grep -i mpath|wc -l",
	"/sbin/multipath -ll|egrep 'active(.*)running|active(.*)ready'|wc -l",
	"/gns/software/infra/cpe/storage/gssantool/gssantool-prod/gssantool -m|egrep -i 'Path.*ONLINE.*Port:.'",
	"/gns/software/infra/cpe/storage/gssantool/gssantool-prod/gssantool -m|egrep -i 'storage|DeviceID' |wc -l",
	"/gns/software/infra/cpe/storage/gssantool/gssantool-prod/gssantool -m|awk '{print $4}' |egrep -i port |sort -u"]
	multi_execcmds_list=executeSSHCommand(multipath_cmd_list,';',str(host))
	if multi_execcmds_list!='ops_auto_error':
		multipath_res_str=multi_execcmds_list[0]
		total_devices=multi_execcmds_list[1]
		logMsg("Total devices are "+str(total_devices),"INFO")
		active_paths=multi_execcmds_list[2]
		logMsg("Total active/running paths are "+str(active_paths),"INFO")
		gssantool_op=multi_execcmds_list[3]
		total_devices_frm_gssantool=multi_execcmds_list[4]
		logMsg("Total devices from gssantool file are "+str(total_devices_frm_gssantool),"INFO")
		uniq_ports=multi_execcmds_list[5]
		if multipath_res_str!='':
			try:
				total_devices=int(total_devices)
				if total_devices==int(total_devices_frm_gssantool):
					luns_ok_value="OK"
					luns_err_msg=""
				else:
					luns_ok_value="NOT-OK"
					luns_err_msg="Check Manually!"
				gssantool_op_list=gssantool_op.split('\n')
				active_paths_frm_gssantool=len(gssantool_op_list)
				logMsg("Total active paths from gssantool file are "+str(active_paths_frm_gssantool),"INFO")
				active_paths=int(active_paths)
				if active_paths==active_paths_frm_gssantool:
					ports=uniq_ports.split("\n")
					counts=[]
					#Iterating over the lines of gssantool output and counting the appearances of each port at the end of the line
					#and storing that count in counts[] list 
					for port in ports:
						c=0
						for elem in gssantool_op_list:
							if elem.endswith(port):
								c=c+1
						counts.append(c)
					#converting the list into set if paths are equally distributed over each port
					#then length of this set would be one which is good case
					count_set=set(counts)
					logMsg("count set is "+str(count_set),"INFO")
					count_set_len=len(count_set)
					logMsg("length of count set is "+str(count_set_len),"INFO")
					if count_set_len==1 and luns_ok_value=="OK":
						ok_value="OK"
						err_msg=""
					else:
						if luns_ok_value=="NOT-OK":
							err_msg="Storage Devices count mismatch from gssantool and multipath -ll output"
						else:
							err_msg="Paths are not equally distributed!"
						ok_value="NOT-OK"
						
				else:
					ok_value="NOT-OK"
					err_msg="ACTIVE PATH COUNT NOT-OK, Few paths are not running!"
			except Exception as e:
				logMsg(str(sys.exc_info()[0].__name__)+" Occurred: "+str(e),"ERROR")
				logMsg("Multipath check module failed!","ERROR")
				return_code='ops_auto_error'
		else:
			logMsg("Only location corresponding to multipath exists, but there is no multipath","INFO")
			ok_value="OK"
			total_devices="-"
			active_paths_frm_gssantool="-"
			err_msg="Not-Applicable!"
			luns_ok_value="OK"
			luns_err_msg="Not-Applicable!"
	else:
		logMsg("Multipath check module failed!","ERROR")
		return_code='ops_auto_error'
	storage_luns_msg = host.ljust(35) + "STORAGE-MULTIPATH-LUNS".ljust(25) + str(total_devices).ljust(15) + luns_ok_value.ljust(15)+ luns_err_msg.ljust(30)
	storage_paths_msg = host.ljust(35) + "STORAGE-MULTIPATHS".ljust(25) + str(active_paths_frm_gssantool).ljust(15) + ok_value.ljust(15)+ err_msg.ljust(30)
	if post_check != 1:
		print(storage_luns_msg)
		print(storage_paths_msg)
	writeFile(outputfile,storage_luns_msg)
	output_list.append(storage_luns_msg)
	writeFile(outputfile,storage_paths_msg)
	output_list.append(storage_paths_msg)
	if err_msg!="":
		writeFile(errorfile,storage_paths_msg)
	if luns_err_msg!="":
		writeFile(errorfile,storage_luns_msg)
	return return_code
#============================================================================================
# Function to check powerpath failure
#============================================================================================
def powerpath(host):
	logMsg("powerpath(host)","DEBUG")
	global post_check
	return_code='OK'
	global os_type
	total_devices=0
	final_active_paths=0
	final_total_paths=0
	ok_value="NOT-OK"
	luns_ok_value="NOT-OK"
	err_msg="Expected output not found!"
	luns_err_msg="Expected output not found!"
	if(os_type==1):
		powerpath_cmd_list=["/sbin/powermt display dev=all",
		"/sbin/powermt display dev=all |egrep 'Pseudo name' |wc -l"]
	elif(os_type==2):
		powerpath_cmd_list=["/etc/powermt display dev=all",
		"/etc/powermt display dev=all |egrep 'Pseudo name' |wc -l"]
	power_execcmds_list=executeSSHCommand(powerpath_cmd_list,';',str(host))
	if power_execcmds_list!='ops_auto_error':
		powermt_display_op=power_execcmds_list[0]
		total_devices=power_execcmds_list[1]
		try:
			total_devices=int(total_devices)
			if powermt_display_op!='':
				try:
					luns_ok_value="OK"
					luns_err_msg=""
					powermt_display_op+=(str('\n'))
					powermt_display_op_list=powermt_display_op.split('\n')
					path_check_flag=False
					err_list=[]
					ok_list=[]
					total_paths=0
					active_paths=0
					all_lines=[]
					for i in range(len(powermt_display_op_list)):
						line=powermt_display_op_list[i]
						re_result=re.search("\s+\d+\s+lpfc",line,re.IGNORECASE)
						if re_result:
							all_lines.append(line.strip())
							total_paths=total_paths + 1						
							path_check_flag=True
							if re.search("\s+\d+\s+lpfc .* alive",line,re.IGNORECASE):			
								active_paths=active_paths + 1
						else:
							if (path_check_flag):
								final_active_paths=final_active_paths+active_paths
								final_total_paths=final_total_paths+total_paths
								path_check_flag=False
								if(active_paths == 0):  
									err_list.append("SAN Powerpath critical failure condition: all paths to device failed")
								elif(active_paths != total_paths):
									err_list.append("SAN Powerpath failure condition: some paths to device failed/degraded")
								elif((total_paths % 2) == 1): 
									err_list.append("SAN Powerpath error condition: Single path or odd number of paths to a device")
								else:
									ok_list.append("All Powerpath paths are in active ready state and are OK")
							total_paths=0
							active_paths=0
					if not err_list:
						counts=[]
						#Extracting the starting numbers from main lines of each block of the output
						all_numbers=set(x[0] for x in all_lines)
						logMsg("Starting numbers from powermt displat dev=all command are :"+str(all_numbers),"INFO") 
						#Iterating over the lines and counting the appearances of each number in the starting of the line
						#and storing that count in counts[] list 
						for num in all_numbers:
							c=0
							for i in all_lines:
								if i.startswith(str(num)):
									c=c+1
							counts.append(c)
						logMsg("counts List is "+str(counts),"DEBUG")
						#converting the list into set if each number is distributed equally
						#then length of this set would be one which is good case
						count_set=set(counts)
						logMsg("count_set in powerpath is "+str(count_set),"INFO")
						set_length=len(count_set)
						logMsg("Length of count set in powerpath is "+str(set_length),"INFO")
						if set_length==1:
							ok_value="OK"
							err_msg=""
							logMsg("All Powerpaths are online","INFO")
							success_case_val="\n\n In Powerpath output of powermt display dev=all command is\n" +str(powermt_display_op)
							logMsg(str(success_case_val),"INFO")
						else:
							ok_value="NOT-OK"
							err_msg="Paths are not equally distributed!"
					else:
						ok_value="NOT-OK"
						err_msg="Few paths are not alive!"
						logMsg("ODD number of Powerpaths found","INFO")
					logMsg("Total Powerpaths are: "+str(final_total_paths),"INFO")
					logMsg("Active Powerpaths are: "+str(final_active_paths),"INFO")
				except Exception as e:
					logMsg(str(sys.exc_info()[0].__name__)+" Occurred while finding that All Powerpath paths are in active ready state or not : "+str(e),"INFO")
					return_code='ops_auto_error'
			else:
				logMsg("Only location corresponding to Powerpath exists but there is no powerpath","INFO")
				ok_value="OK"
				total_devices="-"
				final_active_paths="-"
				err_msg="Not-Applicable!"
				luns_ok_value="OK"
				luns_err_msg="Not-Applicable!"
		except Exception as e:
			logMsg(str(sys.exc_info()[0].__name__)+" Occurred: "+str(e),"ERROR")
			final_active_paths="-"
			total_devices="-"
			return_code='ops_auto_error'
	else:
		logMsg("Powerpath check module failed!","ERROR")
		return_code='ops_auto_error'
	storage_luns_msg = host.ljust(35) + "STORAGE-POWERPATH-LUNS".ljust(25) + str(total_devices).ljust(15) + luns_ok_value.ljust(15)+ luns_err_msg.ljust(30)
	storage_paths_msg = host.ljust(35) + "STORAGE-POWERPATHS".ljust(25) + str(final_active_paths).ljust(15) + ok_value.ljust(15)+ err_msg.ljust(30)
	if post_check != 1:
		print(storage_luns_msg)
		print(storage_paths_msg)
	writeFile(outputfile,storage_luns_msg)
	output_list.append(storage_luns_msg)
	writeFile(outputfile,storage_paths_msg)
	output_list.append(storage_paths_msg)
	if err_msg!="":
		writeFile(errorfile,storage_paths_msg)
	if luns_err_msg!="":
		writeFile(errorfile,storage_luns_msg)
	return return_code
#============================================================================================
# Function to check HBA ports count on linux and SunOS
#============================================================================================
def hbaPortCountCheck(host):
	logMsg("hbaPortCountCheck(host)","DEBUG")
	global post_check
        global os_type
        return_code='OK'
        hba_port_count="-"
        logMsg("os_type is "+str(os_type),"DEBUG")
        if(os_type==1):
                hba_port_count_cmd_list=["/opt/gs-utils/inq -hba|egrep 'port WWN|port state'","/opt/gs-utils/inq -hba | grep 'port state\:'|grep -i online | wc -l"]
        elif(os_type==2):
                hba_port_count_cmd_list=["/etc/inq -hba|egrep 'port WWN|port state'","/etc/inq -hba | grep 'port state\:'|grep -i online | wc -l"]
        hba_port_execcmds_list=executeSSHCommand(hba_port_count_cmd_list,';',str(host))
        all_ports_online=False
        if hba_port_execcmds_list!='ops_auto_error':
                hba_port_status=hba_port_execcmds_list[0]
                hba_port_count=hba_port_execcmds_list[1]
                if (hba_port_status != ''):
                        try:
                                hba_port_count=int(hba_port_count)
                        except Exception as e:
                                logMsg(str(sys.exc_info()[0].__name__)+" Occurred while finding hba port count ,Port count value not found :"+str(e),"ERROR")
                                return_code='ops_auto_error'
                                hba_port_count='-'
                else:
                        return_code='ops_auto_error'
                        hba_port_count="-"
                if return_code !='ops_auto_error':
                        if(hba_port_count==0):
                                logMsg("\n Output of hba port status is : \n"+str(hba_port_status),"INFO")
                                logMsg("\n\n All HBA ports are OFFLINE/DOWN : "+str(hba_port_count),"INFO")
                                hba_port_msg = host.ljust(35) + "HBA-PORTS".ljust(25) + str(hba_port_count).ljust(15) + "NOT-OK".ljust(15)
                                return_code='OK'
                        elif hba_port_count%2!=0:
                                logMsg("\n Output of hba port status is : \n"+str(hba_port_status),"INFO")
                                logMsg("\n\n ODD Number of hba ports ONLINE : "+str(hba_port_count),"INFO")
                                hba_port_msg = host.ljust(35) + "HBA-PORTS".ljust(25) + str(hba_port_count).ljust(15) + "NOT-OK".ljust(15)
                                return_code='OK'
                        else:
                                logMsg("\n Output of hba port status is : \n"+str(hba_port_status),"INFO")
                                logMsg("\n\n Even number of hba ports ONLINE : "+str(hba_port_count),"INFO")
                                hba_port_msg = host.ljust(35) + "HBA-PORTS".ljust(25) + str(hba_port_count).ljust(15) + "OK".ljust(15)
                                all_ports_online=True
                                return_code='OK'
                else:
                                logMsg("\n\n Unable to find number of Online hba ports\n","ERROR")
                                err_msg = "Expected output not found!"
                                hba_port_msg = host.ljust(35) + "HBA-PORTS".ljust(25) + str(hba_port_count).ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
                                return_code='ops_auto_error'
        else:
                logMsg("\n\n HBA Port Count Check module failed!","ERROR")
                err_msg = "Expected output not found!"
                hba_port_msg = host.ljust(35) + "HBA-PORTS".ljust(25) + str(hba_port_count).ljust(15) + "NOT-OK".ljust(15) + err_msg.ljust(30)
                return_code='ops_auto_error'
	if post_check != 1:
	        print(hba_port_msg)
        writeFile(outputfile,hba_port_msg)
        if all_ports_online==False:
                writeFile(errorfile,hba_port_msg)
        output_list.append(hba_port_msg)
        return (return_code,hba_port_count)
#=========================================================================================
# Function to get OS type (linux/SunOS)
# and to check path corresponding to multipath and powerpath exists or not
#=========================================================================================
def pathChecking():
	logMsg("pathChecking()","DEBUG")
	global post_check
        global os_type
        global journal
        global power_path_li
        global power_path_so
        global multi_path
        pathvals=[]
        return_code=0
        os_and_path_check_cmd_list = ["uname","if [ -f \"" + str(power_path_li)+ "\" ]; then echo 'powerpath'; else echo 'powerpath not found'; fi;if [ -f \"" + str(power_path_so)+ "\" ]; then echo 'SunOS powerpath'; else echo 'SunOS powerpath not found'; fi; if [ -f \"" + str(multi_path) + "\" ]; then echo 'multipath'; else echo 'multipath not found'; fi;"]
        execute_cmds_res=executeSSHCommand(os_and_path_check_cmd_list,';',str(host))
        if execute_cmds_res!='ops_auto_error':
                os_name=execute_cmds_res[0]
                logMsg("OS Name is " +str(os_name),"INFO")
                if(os_name):
                        if os_name=='Linux'or os_name=='Linux2':
                                os_type=1
                        elif os_name=='SunOS':
                                os_type=2
                        else:
                                os_type=0
                if os_type:
                        pathvals=execute_cmds_res[1].split('\n')
                        return_code='OK'
                else :
                        journal=journal+"Invalid Operating System Found"
                        logMsg(str(journal),"ERROR")
                        return_code='ops_auto_error'
        else:
                journal=journal+"OS and Path check module failed!"
                logMsg(str(journal),"ERROR")
                return_code='ops_auto_error'
        return (return_code,pathvals)
#============================================================================================
#MAIN Function which calls other functions based on the criteria matched
#============================================================================================
def multiPowerMain(host):
	global post_check
	logMsg("multiPowerMain(host)","DEBUG")
	global os_type
	return_code='OK'
	path_pow_linux = ''
	path_pow_sol = ''
	path_multi = ''
	ret_code_power='ops_auto_error'
	ret_code_multi='ops_auto_error'
	total_devices="-"
	final_active_paths="-"
	ok_value="NOT-OK"
	luns_ok_value="NOT-OK"
	err_msg="Expected output not found!"
	luns_err_msg="Expected output not found!"
	paths_found=False
	hba_ports='-'
	hba_err_msg="Expected output not found!"
	ret_code_path_chk,pathvalues=pathChecking()
	if ret_code_path_chk!='ops_auto_error':
		path_pow_linux=pathvalues[0]
		path_pow_sol=pathvalues[1]
		path_multi=pathvalues[2]
		ret_code_hba_port_check,hba_ports=hbaPortCountCheck(host)
		if hba_ports!='-':
			if ((path_pow_linux =="powerpath" or path_pow_sol=="SunOS powerpath") and path_multi =="multipath") and (os_type==1 or os_type==2):
				logMsg("Executing both powerpath and multipath because both paths exists","INFO")
				ret_code_multi=multipath(host)
				ret_code_power=powerpath(host)
				paths_found=True
			elif (path_pow_linux=="powerpath" and os_type==1):
				logMsg("Executing powerpath only for linux","INFO")
				ret_code_power=powerpath(host)
				paths_found=True				
			elif (path_pow_sol=="SunOS powerpath" and os_type==2):
				logMsg("Executing powerpath only for SunOS","INFO")
				ret_code_power=powerpath(host)
				paths_found=True
			elif (path_multi=="multipath" and os_type==1):
				logMsg("Executing multipath only for linux","INFO")
				ret_code_multi=multipath(host)
				paths_found=True
			else:
				logMsg("Unable to find path locations for multipath, powerpath or both","INFO")
				err_msg="Storage Paths not Found!"
				luns_err_msg="Storage Paths not Found!"
				paths_found=False
	else:
		paths_found=False
		#hbaPortCountcheck function would not be called if pathChecking function returned ops_auto_error
		#hence printing hba ports error message
		hba_port_msg = host.ljust(35) + "HBA-PORTS".ljust(25) + str(hba_ports).ljust(15) + "NOT-OK".ljust(15) + hba_err_msg.ljust(30)
		#printing and writing HBA PORT error message to error file and output file
		if post_check != 1:
			print(hba_port_msg)
		writeFile(outputfile,hba_port_msg)
		writeFile(errorfile,hba_port_msg)
		#appending hba port message to output list
		output_list.append(hba_port_msg)
	if paths_found==False:
		#printing and writing error messages for multipath to error file and output file
		storage_luns_msg = host.ljust(35) + "STORAGE-POWERPATH-LUNS".ljust(25) + str(total_devices).ljust(15) + luns_ok_value.ljust(15)+ luns_err_msg.ljust(30)
		storage_paths_msg = host.ljust(35) + "STORAGE-POWERPATHS".ljust(25) + str(final_active_paths).ljust(15) + ok_value.ljust(15)+ err_msg.ljust(30)
		if post_check != 1:
			print(storage_luns_msg)
			print(storage_paths_msg)
		writeFile(outputfile,storage_luns_msg)
		writeFile(errorfile,storage_luns_msg)
		writeFile(outputfile,storage_paths_msg)
		writeFile(errorfile,storage_paths_msg)
		#appending powerpath messages to output list
		output_list.append(storage_luns_msg)
		output_list.append(storage_luns_msg)
		#printing and writing error messages for multipath to error file and output file 
		storage_luns_msg = host.ljust(35) + "STORAGE-MULTIPATH-LUNS".ljust(25) + str(total_devices).ljust(15) + luns_ok_value.ljust(15)+ luns_err_msg.ljust(30)
		storage_paths_msg = host.ljust(35) + "STORAGE-MULTIPATHS".ljust(25) + str(final_active_paths).ljust(15) + ok_value.ljust(15)+ err_msg.ljust(30)
		if post_check != 1:
			print(storage_luns_msg)
			print(storage_paths_msg)
		writeFile(outputfile,storage_luns_msg)
		writeFile(errorfile,storage_luns_msg)
		writeFile(outputfile,storage_paths_msg)
		writeFile(errorfile,storage_paths_msg)
		#appending multipath messages to output list
		output_list.append(storage_luns_msg)
		output_list.append(storage_luns_msg)
		return_code='ops_auto_error'
	if ret_code_hba_port_check=='ops_auto_error' or ret_code_multi=='ops_auto_error' or ret_code_power=='ops_auto_error':
		return_code='ops_auto_error'
	return return_code
#---------------------------------------------------------------------------------------------
# NETWORK CHECKOUT
# AUTHOR : Uddyan Sinha
#---------------------------------------------------------------------------------------------
# Function to execute ethtool command
#------------------------------------------------------------------------------------------------------------------
def ethtoolExecution(eth_name,host):
        logMsg("ethtoolExecution(eth_name,host)",'DEBUG')
        varValidate('list','eth_name',eth_name)
        varValidate('string','host',host)
        global post_check
        device_down=[]#list of devices whose duplex or link detected value is down
        ethtool_command_list=[]#ethtool command list
        try:
                for i in range(len(eth_name)):
                        ethtool_command_list.append("ethtool "+eth_name[i])
                logMsg("The command to be executed is :"+str(ethtool_command_list),'INFO')
                ethtool_output=executeSSHCommand(ethtool_command_list,';',str(host))
                if(ethtool_output=='ops_auto_error' or ethtool_output==''):
                        logMsg("ethtool output error for the device ",'INFO')
                        err_msg = "Expected output not found!"
                        msg = host.ljust(35) + "ETHTOOL ".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15)+ err_msg.ljust(30)
                        output_list.append(msg)
                        if post_check != 1:
                                print(msg)
                        logMsg(msg,"DEBUG")
                        writeFile(errorfile,msg)
                        writeFile(outputfile,msg)
                for i in range(len(ethtool_output)):
                        device=[]
                        duplex=[]
                        link=[]
                        str_ethtool_output=''.join(ethtool_output[i])
                        eth_device_match=findPatterns(str_ethtool_output,['Settings for','Duplex','Link detected'],starts_with_pattern='yes')
                        eth_device_split=eth_device_match.split("\n")
                        if len(eth_device_split)==3:
                                        device=eth_device_split[0].split(" ")
                                        device[2]=(device[2][:-1]).strip()#Stripping out the last character
                                        logMsg("The eth device extracted is "+str(device[2]),'INFO')
                                        if device[2].startswith("eth"):
                                                duplex=eth_device_split[1].split(":")
                                                duplex[1]=duplex[1].strip()
                                                link=eth_device_split[2].split(":")
                                                link[1] =link[1].strip()
                                                logMsg("For :"+str(device[2])+" duplex value is :"+str(duplex[1])+" Link detected is "+str(link[1]),'INFO')
                                                if duplex[1].lower()=='full' and link[1].lower()=='yes' :
                                                        logMsg("Duplex value is full and link detected is yes for the device "+str(device[2]),'INFO')
                                                else:
                                                        logMsg("The following device is appended in device down "+str(device[2]),'INFO')
                                                        device_down.append(device[2].strip())

                                        else:
                                                logMsg("No eth devices in corresponding ethtool command output",'ERROR')
                                                return ('failure',device_down)
                        else:
                                logMsg("Device,duplex or link anyone is missing",'ERROR')
                                return ('failure',device_down)
                return ('success',device_down)
        except Exception as e:
                logMsg("Ethtool execution for network checkout failed! :" + str(e),"ERROR")
                return 'ops_auto_error'
#----------------------------------------------------------------------------------------------------------
# Function to check Network Interfaces
#----------------------------------------------------------------------------------------------------------
def checkNetworkInterface(host):
        logMsg("checkNetworkInterface(host)","DEBUG")
        varValidate('string','host',host)
        global post_check
        flag_bond=0#flag to set slave interface less than two
        flag_networkip_eth=0#flag to set the network ipaddr for the eth devices,success=4 and failure=5
        flag_networkip_bond=0#flag to set the network ipaddr for the bond devices,success=4 and failure=5
        flag_nic_eth=0#flag to set nic full duplex for the eth devices,success=6 and failure=7
        flag_nic_bond=0#flag to set nic full duplex for the bond devices,success=6 and failure=7
        flag_network_interface_eth=0#flag to set the network interfaces for eth devices,success=8,failure=9
        flag_network_interface_bond=0#flag to set the network interfaces for bond devices,success=8,failure=9
        flag_networkip_bond_mismatch=0#flag to set in case of failure for bond,failure=11
        flag_networkip_eth_mismatch=0#flag to set in case of failure for eth,failure=11
        eth_alone_devices_down=[]#eth devices which are not bonded and down
        bonded_devices_down=[]#bonded eth devices which are down
        bond_ipaddr_down=[]#list of bond devices whose ipaddr not present but inet addr present
        eth_ipaddr_down=[]#list of eth devices whose ipaddr not present but inet addr present
        count_bond_ipaddr_down=0#count of bond devices whose ipaddr not present but inet addr present
        count_eth_ipaddr_down=0#count of eth devices whose ipaddr not present but inet addr present
        count_bond_down=0#count of bond devices whose slave interface count is less than 2
        count_eth_ip_up=0#count of eth devices whose ip address are up
        count_eth_ip_down=0#count of eth devices whose ip address are down
        count_bond_ip_down=0#count of bonded devices whose ip address are down
        count_bond_device_up=0#count of bonded devices which are up(only bond)
        count_bond_device_down=0#count of bonded eth devices which are down
        count_alone_eth_down=0#count of stand alone eth devices which are down
        count_eth=0#count of stand alone eth devices which are up
        count_eth_bond=0#count of eth devices which are in bond(total)
        count_bond_ip_up=0#count of bond devices whose ip is up
        count_infini_up=0#count of infiniband devices which are up
        count_infini=0#count of standalone infiniband devices
        count_infini_down=0#count of infiniband devices which are down
        total_down=0#count of infiniband and eth devices total which are down
        ifconfig_bond=[]#represents the list of bond from ifconfig output on the linux server
        infini_up=[]#List of infini band devices which are up
        infini_down=[]#List of infini band devices which are down
        final_bond=[]#Bonds which are viable and can be used in cat /proc/net command
        eth_name=[]#represents the name of eth devices inside bond
        ifcfg_eth=[]#represents eth devices from ifcfg output onboot='Yes' and IPADDR
        ifcfg_bond=[]#represents bond from ifcfg output onboot='Yes' and IPPADDR
        ifcfg_onboot_bond=[]#represents bonds with onboot='Yes'
        ifcfg_onboot_eth=[]#represents eths with onboot='Yes'
        ifconfig_eth=[]#represents the eth device
        bond_down=[]#list of bond whose slave interface is less than 2
        bond_check=[]#list of bond which are up
	down_ip=[]#network ip address error,list of devices(total list display)G
	down_device=[]#devices which are down(total list display) for interface
	down_nic=[]#total nic devices down(list display)
	bonding_down=[]#total bons devices down(list display)
        run_command=["grep -lr 'ONBOOT=yes' \$(grep -lr 'IPADDR' /etc/sysconfig/network-scripts/ifcfg-*)","grep -lr 'ONBOOT=yes' /etc/sysconfig/network-scripts/ifcfg-*"]
        grep_output_ipaddr=executeSSHCommand(run_command,';',str(host))
        if(grep_output_ipaddr=='ops_auto_error' or grep_output_ipaddr==''):
                logMsg("Error in executing the grep output command in the Linux server ","ERROR")
                err_msg = "Expected output not found!"
                msg = host.ljust(35) + "ONBOOT-YES-COMMAND".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15)+ err_msg.ljust(30)
                output_list.append(msg)
                if post_check != 1:
                        print(msg)
                logMsg(msg,"DEBUG")
                writeFile(errorfile,msg)
                writeFile(outputfile, msg)
        string_grep=''.join(grep_output_ipaddr[0])
        string_split=string_grep.split("\n")
        for i in range(len(string_split)):
                if 'eth' in string_split[i] or 'ib' in string_split[i]:
                                eth_str=string_split[i]
                                eth_list=eth_str.split("-")[2]
                                ifcfg_eth.append(eth_list.strip())
                                #logMsg("ifcfg_eth appended by the ifcfg output eth",'DEBUG')
                if ('bond' in string_split[i] or 'lo:' in string_split[i]) and 'bonding' not in string_split[i]:
                                eth_bond=string_split[i]
                                bond_list=eth_bond.split("-")[2]
                                ifcfg_bond.append(bond_list.strip())
                                #logMsg("ifcfg_bond appended by the ifcfg output bond",'DEBUG')
        string_grep_onboot=''.join(grep_output_ipaddr[1])
        string_grep_onboot_split=string_grep_onboot.split("\n")
        for i in range(len(string_grep_onboot_split)):
                if 'eth' in string_grep_onboot_split[i] or 'ib' in string_grep_onboot_split[i] :
                                eth_str=string_grep_onboot_split[i]
                                eth_list=eth_str.split("-")[2]
                                ifcfg_onboot_eth.append(eth_list.strip())
                                #logMsg("ifcfg_eth appended by the ifcfg output eth",'DEBUG')
                if ('bond' in string_grep_onboot_split[i] or 'lo:' in string_grep_onboot_split[i]) and 'bonding' not in string_grep_onboot_split[i]:
                                eth_bond=string_grep_onboot_split[i]
                                bond_list=eth_bond.split("-")[2]
                                ifcfg_onboot_bond.append(bond_list.strip())
                                #logMsg("ifcfg_bond appended by the ifcfg output bond",'DEBUG')
        logMsg("The list of ifcfg bond are "+str(ifcfg_bond),'INFO')
        logMsg("The list of ifcfg eth are "+str(ifcfg_eth),'INFO')
        logMsg("The list of ifcfg onboot bond are "+str(ifcfg_onboot_bond),'INFO')
        logMsg("The list of ifcfg onboot eth are "+str(ifcfg_onboot_eth),'INFO')
        if not ifcfg_eth:
                logMsg("There are no eth devices in the ifcfg_eth output",'ERROR')
        if not ifcfg_bond:
                logMsg("There are no bond device in the ifcfg_bond output",'ERROR')
        if_config=executeCommand(r"ssh -q " + host + " " + '/sbin/ifconfig 2>/dev/null')
        if(if_config=='ops_auto_error' or if_config==''):
                logMsg("Error in executing the ifconfig command in the Linux server ","ERROR")
                err_msg = "Expected output not found!"
                msg = host.ljust(35) + "IF-CONFIG".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15)+ err_msg.ljust(30)
                output_list.append(msg)
                if post_check != 1:
                        print(msg)
                logMsg(msg,"DEBUG")
                writeFile(errorfile,msg)
                writeFile(outputfile,msg)
        else:
                config_split=if_config.split("\n")
        i = 0
        while i < len(config_split):
                        if (config_split[i].startswith("bond") or config_split[i].startswith("gsi") or config_split[i].startswith("lo:")):
                                if 'inet addr' in config_split[i+1]:
                                        temp=[] #A list variable which extracts the eth name from bond
                                        temp=config_split[i].split(" ")
                                        logMsg("The string after matching bond is: "+str(temp[0]),'INFO')
                                        ifconfig_bond.append(temp[0].strip())
                        if(config_split[i].startswith("eth") or  config_split[i].startswith("ib")):
                                if 'inet addr' in config_split[i+1]:
                                        temp=config_split[i].split(" ")
                                        logMsg("The string after matching bond is: "+str(temp[0]),'INFO')
                                        ifconfig_eth.append(temp[0].strip())
                        i = i + 1
        logMsg("The list values of ifconfig_bond containing bond is :"+str(ifconfig_bond),'INFO')
        if not ifcfg_onboot_bond:
                logMsg("No bond present in onboot yes",'INFO')
                flag_networkip_bond=4
        else:
                ifcfg_without_ip_bond=[x for x in ifcfg_onboot_bond if x not in ifcfg_bond]
                logMsg("The bonds in ifcfg without ip addr is "+str(ifcfg_without_ip_bond),'INFO')
                if not ifcfg_without_ip_bond:
                        logMsg("No bonds available whose ip adress is down",'DEBUG')
                        logMsg("values of onboot yes and ipaddr matches for bond",'DEBUG')
                        flag_networkip_bond=4
                else:
                        bond_ipaddr_down=[x for x in ifcfg_without_ip_bond if x in ifconfig_bond]
                        logMsg("Checking the bonds down in ifcfg with ifconfig bond whether they are high or not",'DEBUG')
                        logMsg("The bonds in ifcfg whose ip address is not up in ifconfig bond are "+str(bond_ipaddr_down),'DEBUG')
                        if not bond_ipaddr_down:
                                logMsg("None of the bonds without ip adress are not up in ifconfig ",'DEBUG')
                                logMsg("ideal condition for bond",'DEBUG')
                                flag_networkip_bond=4
                        else:
                                logMsg("Mismatch occured in the devices bond",'DEBUG')
                                logMsg("Devices which are not having ip in ifcfg bond but have inet addr in ifconfig bond "+str(bond_ipaddr_down),'INFO')
                                count_bond_ipaddr_down=len(bond_ipaddr_down)
                                flag_networkip_bond_mismatch=11
        if not ifcfg_onboot_eth:
                logMsg("No eth present in onboot yes",'DEBUG')
                flag_networkip_eth=4
        else:
                ifcfg_without_ip_eth=[x for x in ifcfg_onboot_eth if x not in ifcfg_eth]
                logMsg("The eths in ifcfg without ip addr is "+str(ifcfg_without_ip_eth),'DEBUG')
                if not ifcfg_without_ip_eth:
                        logMsg("No eths available whose ip address is down",'DEBUG')
                        logMsg("Values of onboot yes and ipaddr matches for eth",'DEBUG')
                        flag_networkip_eth=4
                else:
                        eth_ipaddr_down=[x for x in ifcfg_without_ip_eth if x in ifconfig_bond]
                        logMsg("The bonds in ifcfg whose ip address is not up in ifconfig eth are "+str(eth_ipaddr_down),'DEBUG')
                        if not eth_ipaddr_down:
                                logMsg("None of the eths without ip adress are not up in ifconfig eth",'INFO')
                                logMsg("ideal condition for eth",'DEBUG')
                                flag_networkip_eth=4
                        else:
                                logMsg("Mismatch occured in the devices eth",'DEBUG')
                                logMsg("Devices which are not having ip in ifcfg eth but have inet addr in ifconfig eth "+str(eth_ipaddr_down),'INFO')
                                count_eth_ipaddr_down=len(eth_ipaddr_down)
                                flag_networkip_eth_mismatch=11

        if not ifcfg_bond:
                logMsg("No bonds available for the devicen,so aborting bond check",'INFO')
                msg = host.ljust(35) + "NETWORK-BONDING".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15) + "Not Applicable".ljust(30)
                output_list.append(msg)
                if post_check != 1:
                        print(msg)
                logMsg(msg,"DEBUG")
                writeFile(errorfile,msg)
                writeFile(outputfile,msg)
                flag_networkip_bond=4
        else:
                if not ifconfig_bond:
                        logMsg("The ifconfig_bond list is empty ,that is bond names in the list",'INFO')
                if not ifconfig_eth:
                        logMsg("The ifconfig_eth list is empty ,that eth names without bonding",'INFO')
                bond_check=[x for x in ifcfg_bond if x not in ifconfig_bond]
                if not bond_check:
                        logMsg("Bond check list is empty",'INFO')
                        count_bond_ip_up=len(ifcfg_bond)
                        logMsg("Count of the bond devices whose ip addr are up "+str(count_bond_ip_up),'INFO')
                        flag_networkip_bond=4
                else:
                        logMsg("The devices whose ip address are not up are "+str(bond_check),'INFO')
                        count_bond_ip_down=len(bond_check)
                        flag_networkip_bond=5
                proc_bond=[x for x in ifcfg_bond if x not in bond_check]
                for i in range(len(proc_bond)):
                        if re.match(("bond[0-9]"),proc_bond[i] ) and not re.match(("bond[0-9]\."),proc_bond[i]) and not re.match(("lo"),proc_bond[i]):
                                final_bond.append(proc_bond[i].strip())
                logMsg("The Bonds available to be used in cat/proc/net/bonding are "+str(final_bond),'INFO')
                if not final_bond:
                        logMsg("No bond available which is up ",'ERROR')
                        msg = host.ljust(35) + "NETWORK-BONDING".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15)
                        output_list.append(msg)
                        if post_check != 1:
                                print(msg)
                        logMsg(msg,"DEBUG")
                        writeFile(errorfile,msg)
                        writeFile(outputfile,msg)
                else:
                        run_command=[]
                        logMsg("Bonds which are up are "+str(final_bond),'INFO')
                        logMsg("For bonded eth devices",'DEBUG')
                        for i in range(len(final_bond)):
                                run_command.append("cat /proc/net/bonding/"+final_bond[i])
                        logMsg("The command to be executed is "+str(run_command),'INFO')
                        output_proc=executeSSHCommand(run_command,';',str(host))
                        if(output_proc=='ops_auto_error' or output_proc==''):
                                logMsg("Error in resulting bond_output cat proc  command",'ERROR')
                                err_msg = "Expected output not found!"
                                msg = host.ljust(35) + "NETWORK-BONDING".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15)+ err_msg.ljust(30)
                                output_list.append(msg)
                                if post_check != 1:
                                        print(msg)
                                logMsg(msg,"DEBUG")
                                writeFile(errorfile,msg)
                                writeFile(outputfile,msg)
                        else:
                                for i in range(len(output_proc)):
                                        str_output_proc=''.join(output_proc[i])
                                        str_split=str_output_proc.split("\n")
                                        eth_find=findPatterns(str_output_proc,['Slave Interface'],starts_with_pattern='yes')
                                        slave_device=eth_find.split("\n")
                                        if len(slave_device)>=2:
                                                for i in range(len(str_split)):
                                                        if 'Slave Interface' in str_split[i]:
                                                                slave=str_split[i].split(":")
                                                                slave[1]=slave[1].strip()
                                                                if slave[1].startswith("ib"):
                                                                        micc=str_split[i+1].split(":")
                                                                        micc[1]=micc[1].strip()
                                                                        duplex=str_split[i+3].split(":")
                                                                        duplex[1]=duplex[1].strip()
                                                                        if micc[1].lower()=='up' and duplex[1].lower()=='full':
                                                                                infini_up.append(slave[1].strip())
                                                                        else:
                                                                                infini_down.append(slave[1].strip())
                                                                elif slave[1].startswith("eth"):
                                                                        eth_name.append(slave[1].strip())
                                                                else:
                                                                        logMsg("The Slave interface not starts with eth or ib: "+str(slave[1]),'INFO')
                                        else:
                                                logMsg("The bond having slave interface less than two "+str(final_bond[i]),'INFO')
                                                flag_bond=1
                                                bond_down.append((final_bond[i]).strip())
                                                logMsg("The bonds appended to bond_down are "+str(bond_down),'INFO')
                        logMsg("List of bonds which are finally present "+str(final_bond),'DEBUG')
                        logMsg("The bond whose slave interface are less than two are "+str(bond_down),'DEBUG')
                        logMsg("List of infiniband slave interfaces which are OK "+str(infini_up),'DEBUG')
                        logMsg("List of infiniband slave interfaces which are NOT OK "+str(infini_down),'DEBUG')
                        logMsg("eth devices which are  in bonds and would be checked in ethtool ,"+str(eth_name),'DEBUG')
                        count_infini_up=len(infini_up)
                        count_infini_down=len(infini_down)
                        if not bond_down and not eth_name and not infini_up and not infini_down and final_bond:
                                msg = host.ljust(35) + "NETWORK-BONDING".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15)+ "Bonded eth or ib device not found".ljust(15)
                                output_list.append(msg)
                                if post_check != 1:
                                        print(msg)
                                logMsg(msg,"DEBUG")
                                writeFile(errorfile,msg)
                                writeFile(outputfile,msg)
                        elif flag_bond==1 and bond_down:
                                logMsg("The list of bonded devices whose slave interface is less than two are :"+str(bond_down),'INFO')
                                count_bond_down=len(bond_down)
                                err_msg = "Slave interface count is less than two"
                                if bond_down:
                                        msg = host.ljust(35) + "NETWORK-BONDING".ljust(25) + str(count_bond_down).ljust(15) + "NOT-OK".ljust(15)+ str(bond_down).ljust(15)+err_msg.ljust(30)
                                        output_list.append(msg)
                                        if post_check != 1:
                                                print(msg)
                                        logMsg(msg,"DEBUG")
                                        writeFile(errorfile,msg)
                                        writeFile(outputfile,msg)
                        elif eth_name and ((not infini_down and not infini_up ) or (infini_down and not infini_up) or (not infini_down and infini_up) or (infini_down and infini_up)):
                                        logMsg("The bonded eth devices present are "+str(eth_name),'INFO')
                                        logMsg("For Bonded eth or ib devices",'DEBUG')
                                        logMsg("List of infini_down devices "+str(infini_down),'DEBUG')
                                        logMsg("List of infini_up devices "+str(infini_up),'DEBUG')
                                        (status,bonded_devices_down)=ethtoolExecution(eth_name,host)
                                        if(status=='success'):
                                                logMsg("Successfully executed,the ethtool execution for bonded eth devices only",'INFO')
                                                if not bonded_devices_down and flag_bond==0 and flag_networkip_bond==4 and not infini_down :
                                                        count_bond_device_up=len(final_bond)
                                                        count_eth_bond=len(eth_name)+len(infini_up)
                                                        logMsg("Devices which have eth or ib in bond are "+str(count_eth_bond),'INFO')
                                                        logMsg("Devices only with bond are "+str(count_bond_device_up),'INFO')
                                                        logMsg("The bonded eth device list is empty",'INFO')
                                                        logMsg("None of the bonded eth devices or ib devices are down",'INFO')
                                                        logMsg("All the bonded eth or ib interfaces are up",'INFO')
                                                        flag_nic_bond=6
                                                        flag_network_interface_bond=8
                                                        if count_bond_device_up:
                                                                msg = host.ljust(35) + "NETWORK-BONDING".ljust(25) + str(count_bond_device_up).ljust(15) + "OK".ljust(15)
                                                                output_list.append(msg)
                                                                if post_check != 1:
                                                                        print(msg)
                                                                logMsg(msg,"DEBUG")
                                                                writeFile(outputfile,msg)
                                                elif flag_networkip_bond==5 and not bonded_devices_down and not infini_down:
                                                        count_bond_device_up=len(final_bond)
                                                        count_eth_bond=len(eth_name)+len(infini_up)
                                                        logMsg("There are some bonds which are not down,not all bonds "+str(final_bond),'INFO')
                                                        flag_nic_bond=6
                                                        flag_network_interface_bond=8
                                                        msg = host.ljust(35) + "NETWORK-BONDING".ljust(25) + str(count_bond_device_up).ljust(15) + "OK".ljust(15)
                                                        output_list.append(msg)
                                                        if post_check != 1:
                                                                print(msg)
                                                        logMsg(msg,"DEBUG")
                                                        writeFile(outputfile,msg)
                                                elif not infini_down and not infini_up:
                                                        logMsg("The list of bonded devices which are down are :"+str(bonded_devices_down),'INFO')
                                                        count_bond_device_down=len(bonded_devices_down)
                                                        count_bond_device_up=len(final_bond)
                                                        count_eth_bond=len(eth_name)
                                                        flag_nic_bond=7
                                                        flag_network_interface_bond=9
                                                        logMsg("count of devices which are down are "+str(count_bond_device_down),'INFO')
                                                        if bonded_devices_down:
                                                                msg = host.ljust(35) + "NETWORK-BONDING".ljust(25) + str(count_bond_device_down).ljust(15) + "NOT-OK".ljust(15)+ str(bonded_devices_down).ljust(15)
                                                                output_list.append(msg)
                                                                if post_check != 1:
                                                                        print(msg)
                                                                logMsg(msg,"DEBUG")
                                                                writeFile(errorfile,msg)
                                                                writeFile(outputfile,msg)
                                                elif infini_down and not infini_up:
							logMsg("The list of bonded devices which are down are :"+str(infini_down),'INFO')
							count_bond_device_up=len(final_bond)
                                                        count_infini_down=len(infini_down)
                                                        count_bond_device_down=len(bonded_devices_down)
                                                        total_down=count_infini_down+count_bond_device_down
                                                        flag_nic_bond=7
                                                        flag_network_interface_bond=9
                                                        logMsg("count of devices ib devices which are down are "+str(count_infini_down),'INFO')
                                                        logMsg("The list of bonded devices which are down are :"+str(bonded_devices_down),'INFO')
                                                        logMsg("count of devices which are down are "+str(count_bond_device_down),'INFO')
							bonding_down=infini_down+bonded_devices_down
							if infini_down or bonded_devices_down:
								msg = host.ljust(35) + "NETWORK-BONDING".ljust(25) + str(total_down).ljust(15) + "NOT-OK".ljust(15)+ str(bonding_down).ljust(15)
								output_list.append(msg)
								if post_check != 1:
									print(msg)
								logMsg(msg,"DEBUG")
								writeFile(errorfile,msg)
								writeFile(outputfile,msg)
                                                        
                                                elif not infini_down and infini_up:
                                                        count_bond_device_up=len(final_bond)
                                                        count_bond_device_down=len(bonded_devices_down)
                                                        total_down=count_infini_down+count_bond_device_down
                                                        flag_nic_bond=7
                                                        flag_network_interface_bond=9
                                                        logMsg("count of devices ib devices which are down are "+str(count_infini_down),'INFO')
                                                        logMsg("The list of bonded devices which are down are :"+str(bonded_devices_down),'INFO')
                                                        logMsg("count of devices which are down are "+str(count_bond_device_down),'INFO')
                                                        if bonded_devices_down:
								msg = host.ljust(35) + "NETWORK-BONDING".ljust(25) + str(total_down).ljust(15) + "NOT-OK".ljust(15)+ str(bonded_devices_down).ljust(15)
								output_list.append(msg)
								if post_check != 1:
									print(msg)
								logMsg(msg,"DEBUG")
								writeFile(errorfile,msg)
								writeFile(outputfile,msg)
                                                else:
                                                        count_bond_device_up=len(final_bond)
                                                        count_bond_device_down=len(bonded_devices_down)
                                                        count_infini_down=len(infini_down)
                                                        total_down=count_infini_down+count_bond_device_down
                                                        flag_nic_bond=7
                                                        flag_network_interface_bond=9
                                                        logMsg("count of devices ib devices which are down are "+str(count_infini_down),'INFO')
                                                        logMsg("The list of bonded devices which are down are :"+str(bonded_devices_down),'INFO')
                                                        logMsg("count of devices which are down are "+str(count_bond_device_down),'INFO')
							bonding_down=infini_down+bonded_devices_down
							if infini_down or bonded_devices_down:
								msg = host.ljust(35) + "NETWORK-BONDING".ljust(25) + str(total_down).ljust(15) + "NOT-OK".ljust(15)+ str(bonding_down).ljust(15)
								output_list.append(msg)
								if post_check != 1:
									print(msg)
								logMsg(msg,"DEBUG")
								writeFile(errorfile,msg)
								writeFile(outputfile,msg)
                                        else:
                                                logMsg("Error in execution of ethtool command for bonded",'ERROR')
                                                err_msg = "Expected output not found!"
                                                msg = host.ljust(35) + "NETWORK-BONDING".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15)+err_msg.ljust(30)
                                                output_list.append(msg)
                                                if post_check != 1:
                                                        print(msg)
                                                logMsg(msg,"DEBUG")
                                                writeFile(errorfile,msg)
                                                writeFile(outputfile,msg)
                        elif not infini_down and infini_up and flag_networkip_bond==4:
                                count_bond_device_up=len(final_bond)
                                count_infini_up=len(infini_up)
                                logMsg("Devices which have ib in bond are "+str(count_infini_up),'INFO')
                                logMsg("Devices only with bond are "+str(count_bond_device_up),'INFO')
                                logMsg("The bonded eth device list is empty",'INFO')
                                logMsg("None of the bonded eth devices are down",'INFO')
                                logMsg("All the bonded eth interfaces are up",'INFO')
                                flag_nic_bond=6
                                flag_network_interface_bond=8
                                if count_bond_device_up:
                                        msg = host.ljust(35) + "NETWORK-BONDING".ljust(25) + str(count_bond_device_up).ljust(15) + "OK".ljust(15)
                                        output_list.append(msg)
                                        if post_check != 1:
                                                print(msg)
                                        logMsg(msg,"DEBUG")
                                        writeFile(outputfile,msg)
                        elif not infini_down and infini_up and flag_networkip_bond==5:
                                count_bond_device_up=len(final_bond)
                                count_infini_up=len(infini_up)
                                logMsg("Devices which have ib in bond are "+str(count_infini_up),'INFO')
                                logMsg("Devices only with bond are "+str(count_bond_device_up),'INFO')
                                logMsg("The bonded eth device list is empty",'INFO')
                                logMsg("None of the bonded eth devices are down",'INFO')
                                logMsg("All the bonded eth interfaces are up",'INFO')
                                flag_nic_bond=6
                                flag_network_interface_bond=8
                                if count_bond_device_up:
                                        msg = host.ljust(35) + "NETWORK-BONDING".ljust(25) + str(count_bond_device_up).ljust(15) + "OK".ljust(15)
                                        output_list.append(msg)
                                        if post_check != 1:
                                                print(msg)
                                        logMsg(msg,"DEBUG")
                                        writeFile(outputfile,msg)
                        else:
                                if infini_down:
                                        count_infini_down=len(infini_down)
                                        logMsg("The list of ib devices which are down are :"+str(infini_down),'INFO')
                                        count_bond_device_up=len(final_bond)
                                        err_msg = "ib Interface down"
                                        flag_nic_bond=7
                                        flag_network_interface_bond=9
                                        logMsg("count of devices ib devices which are down are "+str(count_infini_down),'INFO')
					msg = host.ljust(35) + "NETWORK-BONDING".ljust(25) + str(count_infini_down).ljust(15) + "NOT-OK".ljust(15)+ str(infini_down).ljust(15)+err_msg.ljust(30)
					output_list.append(msg)
					if post_check != 1:
						print(msg)
					logMsg(msg,"DEBUG")
					writeFile(errorfile,msg)
					writeFile(outputfile,msg)
        logMsg("Exclude the devices in alone eth which were present inside bonding",'DEBUG')
        logMsg("checking the devices which are present in ifcfg_eth command "+str(ifcfg_eth),'DEBUG')
        logMsg("eth devices in the ifconfig_bond command "+str(eth_name),'DEBUG')
        logMsg("eth devices which are up in ifconfig_eth "+str(ifconfig_eth),'DEBUG')
        logMsg("Removing redundant eths from ifcfg eth command",'DEBUG')
        unique_eth=[x for x in ifcfg_eth if x not in eth_name]
        logMsg("new alone eth values without taking the bonded eths "+str(unique_eth),'INFO')
        eth_ip_down=[]#list of eth devices whose ip is down
        if not unique_eth:
                logMsg("All eths are present inside bonds",'INFO')
                logMsg("No standalone eths present",'INFO')
                flag_networkip_eth=4
        else:
                eth_ip_down=[x for x in unique_eth if x not in ifconfig_eth]
                logMsg("eth devices whose ip is down "+str(eth_ip_down),'INFO')
                if not eth_ip_down:
                        count_eth_ip_up=len(ifcfg_eth)
                        logMsg("Count of ip address device which are up "+str(count_eth_ip_up),'INFO')
                        flag_networkip_eth=4
                else:
                        logMsg("eth devices which are not up are "+str(eth_ip_down),'INFO')
                        count_eth_ip_down=len(eth_ip_down)
                        flag_networkip_eth=5
                        logMsg("Count of eth devices ip which are not up are "+str(count_eth_ip_down),'INFO')
                eth_ip_up=[x for x in unique_eth if x not in eth_ip_down]
                if not eth_ip_up:
                        logMsg("All the stand alone eth devices ip are down "+str(eth_ip_down),'INFO')
                else:
                        eth_up=[]
                        ib_up=[]
                        logMsg("eth standalone devices which are up are "+str(eth_ip_up),'INFO')
                        logMsg("For Stand alone eth devices or ib devices",'DEBUG')
                        for i in range(len(eth_ip_up)):
                                if eth_ip_up[i].startswith("eth"):
                                        eth_up.append(eth_ip_up[i].strip())
                                else:
                                        ib_up.append(eth_ip_up[i].strip())
                        if eth_up:
                                logMsg("eth standalone devices which are up are "+str(eth_ip_up),'INFO')
                                logMsg("For Stand alone eth devices "+str(eth_up),'INFO')
                                logMsg("For Stand alone ib devices "+str(ib_up),'INFO')
                                (status,eth_alone_devices_down)=ethtoolExecution(eth_up,host)
                                if(status=='success'):
                                        logMsg("Successfully executed,the ethtool execution for standalone eth",'INFO')
                                        if not eth_alone_devices_down and flag_networkip_eth==4:
                                                logMsg("The standalone eth device list is empty",'INFO')
                                                logMsg("None of the stand alone ethtool devices are down",'INFO')
                                                logMsg("All the standalone ethtool interfaces are up",'INFO')
                                                flag_nic_eth=6
                                                count_eth=len(eth_up)
                                                logMsg("count_eth of standalone eth devices which are up are "+str(count_eth),'INFO')
                                                flag_network_interface_eth=8
                                                logMsg("All the standalone eth devices are up",'INFO')
                                        elif flag_networkip_eth==5 and not eth_alone_devices_down:
                                                count_eth=len(eth_up)
                                                logMsg("There are some eth alone devices which are up,not all eth devices "+str(eth_up),'INFO')
                                                flag_nic_eth=6
                                                flag_network_interface_eth=8
                                        else:
                                                logMsg("The list of stand alone devices which are down are :"+str(eth_alone_devices_down),'INFO')
                                                count_alone_eth_down=len(eth_alone_devices_down)
                                                count_eth=len(eth_up)
                                                flag_nic_eth=7
                                                flag_network_interface_eth=9
                                else:
                                        logMsg("Error in execution of ethtool command for standalone eth",'ERROR')
                                        err_msg = "Expected output not found!"
                                        msg = host.ljust(35) + "ETHTOOL-COMMAND-ETH".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15)+err_msg.ljust(30)
                                        output_list.append(msg)
                                        if post_check != 1:
                                                print(msg)
                                        logMsg(msg,"DEBUG")
                                        writeFile(errorfile,msg)
                                        writeFile(outputfile,msg)
                        if ib_up:
                                count_infini=len(ib_up)
                                logMsg("Infiniband slave interfaces are present without bonding"+str(ib_up),'INFO')
                                flag_nic_eth=7
                                flag_network_interface_eth=9
                        count_eth=len(eth_up)
                        count_alone_eth_down=len(eth_alone_devices_down)
                        count_infini=len(ib_up)
        logMsg("flag_networkip_eth "+str(flag_networkip_eth),'INFO')
        logMsg("flag_networkip_bond "+str(flag_networkip_bond),'INFO')
        logMsg("flag_nic_eth "+str(flag_nic_eth),'INFO')
        logMsg("flag_nic_bond "+str(flag_nic_bond),'INFO')
        logMsg("flag_network_interface_eth "+str(flag_network_interface_eth),'INFO')
        logMsg("flag_network_interface_bond "+str(flag_network_interface_bond),'INFO')
        logMsg("flag_networkip_bond_mismatch "+str(flag_networkip_bond_mismatch),'INFO')
        logMsg("flag_networkip_eth_mismatch "+str(flag_networkip_eth_mismatch),'INFO')
        if(flag_network_interface_bond==0  and flag_nic_bond==0  and flag_nic_eth==0 and flag_network_interface_eth==0):
                        err_msg = "Expected output not found!"
                        msg = host.ljust(35) + "NIC-FULL-DUPLEX".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15)+ err_msg.ljust(30)
                        output_list.append(msg)
                        if post_check != 1:
                                print(msg)
                        logMsg(msg,"DEBUG")
                        writeFile(errorfile,msg)
                        writeFile(outputfile,msg)
                        msg = host.ljust(35) + "NETWORK-INTERFACES".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15)+ err_msg.ljust(30)
                        output_list.append(msg)
                        if post_check != 1:
                                print(msg)
                        logMsg(msg,"DEBUG")
                        writeFile(errorfile,msg)
                        writeFile(outputfile,msg)
        if(flag_networkip_eth==4 and flag_networkip_bond==4 and flag_networkip_bond_mismatch==0 and flag_networkip_eth_mismatch==0):
                total_ip=0
                total_ip=count_bond_ip_up+count_eth_ip_up
                if not total_ip:
                        msg = host.ljust(35) + "NETWORK-IP-ADDR".ljust(25) + "-".ljust(15) + "NOT-OK".ljust(15)
                        output_list.append(msg)
                        if post_check != 1:
                                print(msg)
                        logMsg(msg,"DEBUG")
                        writeFile(outputfile,msg)
                        writeFile(errorfile,msg)
                else:
                        msg = host.ljust(35) + "NETWORK-IP-ADDR".ljust(25) + str(total_ip).ljust(15) + "OK".ljust(15)
                        output_list.append(msg)
                        if post_check != 1:
                                print(msg)
                        logMsg(msg,"DEBUG")
                        writeFile(outputfile,msg)
        if(flag_networkip_eth==5 or flag_networkip_bond==5 or flag_networkip_bond_mismatch==11 or flag_networkip_eth_mismatch==11 ):
                total_ip=0
                total_ip=count_bond_ip_down+count_eth_ip_down+count_bond_ipaddr_down+count_eth_ipaddr_down
                total_ip=str(total_ip)
                logMsg("The total devices whose ip addr are not perfect are "+str(total_ip),'INFO')
		down_ip=bond_check+eth_ip_down+bond_ipaddr_down+eth_ipaddr_down
		if bond_check or eth_ip_down or bond_ipaddr_down or eth_ipaddr_down :
			msg = host.ljust(35) + "NETWORK-IP-ADDR".ljust(25) + str(total_ip).ljust(15) + "NOT-OK".ljust(15)+ str(down_ip).ljust(30)
			output_list.append(msg)
			if post_check != 1:
				print(msg)
			logMsg(msg,"DEBUG")
			writeFile(errorfile,msg)
			writeFile(outputfile,msg)
        #If only bond devices are up
        if(flag_network_interface_bond==8  and flag_nic_bond==6  and flag_nic_eth==0 and flag_network_interface_eth==0):
                total_interface=0
                total_nic=0
                total_interface=count_eth+count_eth_bond+count_infini_up
                total_interface=str(total_interface)
                msg = host.ljust(35) + "NETWORK-INTERFACES".ljust(25) + str(total_interface).ljust(15) + "OK".ljust(15)
                output_list.append(msg)
                if post_check != 1:
                        print(msg)
                logMsg(msg,"DEBUG")
                writeFile(outputfile,msg)
                total_nic=count_eth_bond+count_eth+count_infini_up
                total_nic=str(total_nic)
                msg = host.ljust(35) + "NIC-FULL-DUPLEX".ljust(25) + str(total_nic).ljust(15) + "OK".ljust(15)
                output_list.append(msg)
                if post_check != 1:
                        print(msg)
                logMsg(msg,"DEBUG")
                writeFile(outputfile,msg)
                #if only eth devices are up
        if(flag_network_interface_bond==0 and  flag_nic_bond==0 and  flag_nic_eth==6 and flag_network_interface_eth==8):
                total_interface=0
                total_nic=0
                total_interface=count_eth+count_infini_up
                total_interface=str(total_interface)
                msg = host.ljust(35) + "NETWORK-INTERFACES".ljust(25) + str(total_interface).ljust(15) + "OK".ljust(15)
                output_list.append(msg)
                if post_check != 1:
                        print(msg)
                logMsg(msg,"DEBUG")
                writeFile(outputfile,msg)
                total_nic=count_eth_bond+count_eth+count_infini_up
                total_nic=str(total_nic)
                msg = host.ljust(35) + "NIC-FULL-DUPLEX".ljust(25) + str(total_nic).ljust(15) + "OK".ljust(15)
                output_list.append(msg)
                if post_check != 1:
                        print(msg)
                logMsg(msg,"DEBUG")
                writeFile(outputfile,msg)

        if(flag_nic_eth==6 and flag_nic_bond==6):
                total_nic=0
                total_nic=count_eth_bond+count_eth+count_infini_up
                total_nic=str(total_nic)
                msg = host.ljust(35) + "NIC-FULL-DUPLEX".ljust(25) + str(total_nic).ljust(15) + "OK".ljust(15)
                output_list.append(msg)
                if post_check != 1:
                        print(msg)
                logMsg(msg,"DEBUG")
                writeFile(outputfile,msg)
        if(flag_nic_eth==7 or flag_nic_bond==7):
                total_nic=0
                total_nic_down=0
                count_nic_full=0
                total_nic=count_eth_bond+count_eth+count_infini_up+count_infini_down
                total_nic_down=len(bonded_devices_down)+len(eth_alone_devices_down)+len(infini_down)
                count_nic_full=total_nic-total_nic_down
		down_nic=bonded_devices_down+eth_alone_devices_down+infini_down+ib_up
		if bonded_devices_down or eth_alone_devices_down or infini_down or ib_up:
			if not ib_up:
				msg = host.ljust(35) + "NIC-FULL-DUPLEX".ljust(25) + str(count_nic_full).ljust(15) + "NOT-OK".ljust(15)+ str(down_nic).ljust(15)
				output_list.append(msg)
				if post_check != 1:
					print(msg)
				logMsg(msg,"DEBUG")
				writeFile(errorfile,msg)
				writeFile(outputfile,msg)
			else:
				err_msg = "Unbonded ib Interface also present,please check manually"
				msg = host.ljust(35) + "NIC-FULL-DUPLEX".ljust(25) + str(count_nic_full).ljust(15) + "NOT-OK".ljust(15)+ str(down_nic).ljust(15)
				output_list.append(msg)
				if post_check != 1:
					print(msg)
				logMsg(msg,"DEBUG")
				writeFile(errorfile,msg)
				writeFile(outputfile,msg)
               
        if(flag_network_interface_eth==8 and flag_network_interface_bond==8):
                total_interface=0
                total_interface=count_eth+count_eth_bond+count_infini_up
                total_interface=str(total_interface)
                msg = host.ljust(35) + "NETWORK-INTERFACES".ljust(25) + str(total_nic).ljust(15) + "OK".ljust(15)
                output_list.append(msg)
		if post_check != 1:
			print(msg)
		logMsg(msg,"DEBUG")
		writeFile(outputfile,msg)
        if(flag_network_interface_eth==9 or flag_network_interface_bond==9):
                total_interface=0
                total_interface=count_eth_bond+count_eth+count_infini+count_infini_up+count_infini_down
                total_interface=str(total_interface)
		down_device=bonded_devices_down+eth_alone_devices_down+infini_down+ib_up
                if bonded_devices_down or eth_alone_devices_down or infini_down or ib_up:
			if not ib_up:
				msg = host.ljust(35) + "NETWORK-INTERFACES".ljust(25) + str(total_interface).ljust(15) + "NOT-OK".ljust(15)+ str(down_device).ljust(15)
				output_list.append(msg)
				if post_check != 1:
					print(msg)
				logMsg(msg,"DEBUG")
				writeFile(errorfile,msg)
				writeFile(outputfile,msg)
                	else:
				err_msg = "Unbonded ib Interface also present,please check manually"
				msg = host.ljust(35) + "NETWORK-INTERFACES".ljust(25) + str(total_interface).ljust(15) + "NOT-OK".ljust(15)+ str(down_device).ljust(15)
				output_list.append(msg)
				if post_check != 1:
					print(msg)
				logMsg(msg,"DEBUG")
				writeFile(errorfile,msg)
				writeFile(outputfile,msg)
               
#-------------------------------------------------------------------------------------------------------------
#=========================================================================================
# MAIN
#-----------------------------------------------------------------------------------------------------------------------------
arg_list=["hardware","software","network","disk","path","storage","memory","cpu","fans","logs","power","temp","os","cfe","nagios","ntp","pre","post","hostfile","help","loglevel"]
try:
        opts, args = getopt.getopt(sys.argv[1:], "HSIdDsmcFlptoCnNPMf:hL:", arg_list)
except getopt.GetoptError, err:
        # print help information and exit:
        print ("\n" + str(err) + "\n") # will print something like "option -a not recognized"
        scriptUsage()
        sys.exit(2)
#----------------------------------------------------------------------------------------------------------------------------
global output_list
output_list = []
current_date = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
today_log_dir = datetime.datetime.now().strftime("%Y%m%d")
err_op_log_files_path = logfile_directory + today_log_dir
# Checking if today's directory is present or not
if not os.path.exists(err_op_log_files_path):
	try:
		os.makedirs(err_op_log_files_path)
	except Exception as e:
		print("Could not create a new directory")
		
op_filename = err_op_log_files_path + '/output_' + current_date
process_id = os.getpid()
logfile = err_op_log_files_path + '/logfile_' + current_date + '_' + str(process_id) + '.txt'
errorfile = err_op_log_files_path + '/errorfile_' + current_date + '_' + str(process_id) + '.txt'
post_check = 0
#----------------------------------------------------------------------------------------------------------------------------
if len(opts) <= 1:
	print("\nNot sufficient options passed!!\n")
	scriptUsage()
	sys.exit(2)
log_level = 1
for o,a in opts:
	if o in ("-L","--loglevel"):
		loglevel = a
		log_level = loglevel
for o, a in opts:
	if o in ("-f", "--hostfile"):
                hostfile = a
		logMsg("path of server file/ name of host is : " + str(hostfile),'INFO')
                server_file_path = hostfile
                if os.path.isfile(server_file_path) and os.path.getsize(server_file_path) > 0:
                        fp = open(server_file_path,'r')
                        hosts = fp.readlines()
                        host_list = [host.rstrip('\n') for host in hosts ]
			logMsg("Host List is : " + str(host_list),'INFO')
                else:
                        host_list = hostfile.split()
			logMsg("Host list is : " + str(host_list),'INFO')
	elif o in ("-P", "--pre"):
		op_filename = err_op_log_files_path + '/pre_' + current_date
	elif o in ("-M", "--post"):
		op_filename = err_op_log_files_path + '/post_' + current_date
		post_check = 1
	elif o in ("-h","--help"):
		scriptUsage()	

for host in host_list:
	outputfile = op_filename + '_' + host + '.txt'
	logMsg("=========================== " + str(host) + " ===========================\n","INFO")
	output_header = "Server Name".ljust(35) + "Component".ljust(25) + "Count/Size".ljust(15) + "Status".ljust(15) +  "Failed Component".ljust(30)
	try:
		try:
			host_validity = socket.gethostbyname(host)
		except Exception as e:
			print("\nInvalid hostname\n")
			continue
		host_type,platform = checkHostAndPlatform(host)
		logMsg("Host type and Platform are as follows : " + str(host_type) + "," + str(platform),'INFO')
		if ((host_type == 'supported') and (platform == 'hp' or platform == 'dell' or platform == 'vm')):
			logMsg("The server is supported and either hp, dell or virtual machine","INFO")
			ping_no_login_stats = checkPingLogin(host)
			if ping_no_login_stats == True:
				logMsg("Host is pingable and SSH'able", "INFO")
				output_margin = "==============================================================================================================".ljust(115)
				if post_check != 1:
					print("\n" + output_header)
					print(output_margin)
				writeFile(outputfile,output_header)
				writeFile(outputfile,output_margin)
				writeFile(errorfile,output_header)
				writeFile(errorfile,output_margin)
				for o, a in opts:
					logMsg("Checking for options ",'DEBUG')
					if o in ("-H","--hardware"):
						logMsg("Option -H is passed!","INFO")
						if platform=="dell":
							checkDellHardware(host)
						if platform=="hp":
							checkHPHardware(host)
					elif o in ("-S","--software"):
						logMsg("Option -S is passed!","INFO")
						checkSoftware(host)
					elif o in ("-I","--network"):
						logMsg("Option -I is passed!","INFO")
						checkNetworkInterface(host)
					elif o in ("-d", "--disk"):
						logMsg("Option -d is passed!","INFO")
						if platform=="dell":
							vdisk_stats = executeCommand("ssh -q " + host + " \"/opt/dell/srvadmin/bin/omreport storage vdisk controller=0\"")
							pdisk_stats = executeCommand("ssh -q " + host + " \"/opt/dell/srvadmin/bin/omreport storage pdisk controller=0\"")
							parseDellDisk(host,vdisk_stats,pdisk_stats)
						if platform=="hp":
							disk_stats = executeCommand("ssh -q " + host + " \"/usr/sbin/hpacucli ctrl all show config\"")
							parseHPDisk(host,disk_stats)
					elif o in ("-D", "--path"):
						logMsg("Option -D is passed!","INFO")
						if platform=="dell" or platform=="hp":
							multiPowerMain(host)
					elif o in ("-s", "--storage"):
						logMsg("Option -s is passed!","INFO")
						if platform=="dell":
							storage_stats = executeCommand("ssh -q " +host + " \"/opt/dell/srvadmin/bin/omreport storage controller\"")
							battery_stats = executeCommand("ssh -q " +host + " \"/opt/dell/srvadmin/bin/omreport storage battery\"")
							parseDellStorageAndBattery(host,storage_stats,battery_stats)
						elif platform=="hp":
							storage_battery_stats = executeCommand("ssh -q " + host + " \"/usr/sbin/hpacucli ctrl all show status\"")
							parseHPStorageAndBattery(host,storage_battery_stats)
					elif o in ("-m", "--memory"):
						logMsg("Option -m is passed!","INFO")
						if platform=="dell":
							memory_stats = executeCommand("ssh -q " +host + " \"/opt/dell/srvadmin/bin/omreport chassis memory\"")
							parseDellMemory(host,memory_stats)
						elif platform=="hp":
							memory_stats = executeCommand("ssh -q " +host + " \"/sbin/hpasmcli -s 'show dimm'\"")
							parseHPMemory(host,memory_stats)
					elif o in ("-c", "--cpu"):
						logMsg("Option -c is passed!","INFO")
						if platform=="dell":
							cpu_stats = executeCommand("ssh -q " +host + " \"/opt/dell/srvadmin/bin/omreport chassis processors\"")
							parseDellCPU(host,cpu_stats)
						elif platform=="hp":
							cpu_stats = executeCommand("ssh -q " +host + " \"/sbin/hpasmcli -s 'show server'\"")
							parseHPCPU(host,cpu_stats)
					elif o in ("-F", "--fans"):
						logMsg("Option -F is passed!","INFO")
						if platform=="dell":
							fan_stats = executeCommand("ssh -q " +host + " \"/opt/dell/srvadmin/bin/omreport chassis fans\"")
							parseDellFan(host,fan_stats)
						elif platform=="hp":
							fan_stats = executeCommand("ssh -q " +host + " \"/sbin/hpasmcli -s 'show fans'\"")
							parseHPFan(host,fan_stats)
					elif o in ("-l", "--logs"):
						logMsg("Option -l is passed!","INFO")
						if platform=="dell":
							alert_log = executeCommand("ssh -q " + host + " \"/opt/dell/srvadmin/bin/omreport system alertlog\"")
							esm_log = executeCommand("ssh -q " + host + " \"/opt/dell/srvadmin/bin/omreport system esmlog\"")
							parseDellLogs(host,alert_log,esm_log)
						elif platform=="hp":
							iml_log = executeCommand("ssh -q " +host + " \"/sbin/hpasmcli -s 'show iml'\"")
							parseHPLogs(host,iml_log)
					elif o in ("-p", "--power"):
						logMsg("Option -p is passed!","INFO")
						if platform=="dell":
							power_stats = executeCommand("ssh -q " + host + " \"/opt/dell/srvadmin/bin/omreport chassis pwrsupplies\"")
							parseDellPowerSupply(host,power_stats)
						elif platform=="hp":
							power_stats = executeCommand("ssh -q " + host + " \"/sbin/hpasmcli -s 'show powersupply'\"")
							parseHPPowerSupply(host,power_stats)
					elif o in ("-t", "--temp"):
						logMsg("Option -t is passed!","INFO")
						if platform=="dell":
							temp_stats = executeCommand("ssh -q " + host + " \"/opt/dell/srvadmin/bin/omreport chassis temps\"")
							parseDellTemperature(host,temp_stats)
						elif platform=="hp":
							temp_stats = executeCommand("ssh -q " + host + " \"/sbin/hplog -t\"")
							parseHPTemperature(host,temp_stats)
					elif o in ("-C","--cfe"):
						logMsg("Option -C is passed!","INFO")
						if platform=="dell" or platform=="hp" or platform=="vm":
							cfe_cmds = ['ls -l /var/is2/state/allclasses','cat /var/is2/state/allclasses|grep -i light']
							cfe_output = executeSSHCommand(cfe_cmds,';',host)
							parseCFE(host,cfe_output)
					elif o in ("-n","--nagios"):
						logMsg("Option -n is passed!","INFO")
						if platform=="dell" or platform=="hp" or platform=="vm":
							nagios_cmds = ["cat /etc/gs-release",
								"ps -aef|grep -i nagios|grep -v grep",
								"if [ -f \"" + str(log_path) + "\" ]; then grep -w 'connected to.*esm.services.gs.com.*' /var/log/nagios/agent.log; else echo 'path does not exists';fi",
								"if [ -f \"" + str(config1_path) + "\" ]; then cat /local/opt/nagios-agent/etc/nagios-agents.cfg |egrep -i 'stag|qa';else echo 'path does not exists';fi",
								"if [ -f \"" + str(config2_path) + "\" ]; then cat /opt/nagios-agent/etc/nagios-agents.cfg |egrep -i 'stag|qa';else echo 'path does not exists';fi",
								"if [ -f \"" + str(gns_agent_path) + "\" ]; then echo 'path exists'; else echo 'path does not exist'; fi",
								"if [ -f \"" + str(gns_perl_path) + "\" ]; then echo 'path exists'; else echo 'path does not exist'; fi",
								"if [ -f \"" + str(gns_recovery_path) + "\" ]; then echo 'path exists'; else echo 'path does not exist'; fi",
								"rpm -q gs-esm-nagios"]
							nagios_stats = executeSSHCommand(nagios_cmds,";",host)
							parseNagios(host,nagios_stats)
					elif o in ("-o","--os"):
						logMsg("Option -o is passed!","INFO")
						if platform=="dell" or platform=="hp" or platform=="vm":
							os_stat = executeCommand("ssh -q " + host + " \"cat /etc/gs-version\"")
							parseOSVersion(host,os_stat)
					elif o in ("-N","--ntp"):
						logMsg("Option -N is passed!","INFO")
						if platform=="dell" or platform=="hp" or platform=="vm":
							ntpd_stats = executeCommand("ssh -q " + host + " \"service ntpd status\"")
							ntpq_stats = executeCommand("ssh -q " + host + " \"ntpq -p\"")
							parseNTP(host,ntpd_stats,ntpq_stats)
			else:
				logMsg("Ping No Login is False","INFO")
				continue
		else:
			msg = host.ljust(35) + "Not Supported".ljust(20)
			logMsg(msg,'ERROR')
			if post_check != 1:
				print(msg)
			writeFile(outputfile,msg)
			writeFile(errorfile,msg)
			continue
	except Exception as e:
		print("Error occurred for host ".ljust(30) + str(host).ljust(35) + "Exception : " + str(e))
		logMsg("Error occurred for host ".ljust(30) + str(host).ljust(35) + "Exception : " + str(e) ,"ERROR")
	logMsg("=============================================================================\n","INFO")
	#print("\n")
for o,a in opts:
	if o in ("-P", "--pre"):
		pass
	elif o in ("-M", "--post"):
		checkPrePost()
	elif o in ("-f", "--hostfile"):
		hostfile = a
#-----------------------------------------------------------------------------------------------------------------------------
# END
#-----------------------------------------------------------------------------------------------------------------------------

WINDOWS


##	Author-   	Kavita Negi																		01-June-2015	 ##
##  Script-		WindowsCheckOut.ps1 															v1.0             ##
###################################################################################################################
##.SYNOPSIS																										  ##
## This script is used as a one stop tool to do windows checkout 												  ##
## Script requires Powershell Version 3.0 to run																  ##
## Run command: .\\WindowsCheckOut.ps1  <server/file>															  ##
##.EXAMPLE 																										  ##
## PS Z:\Projects> .\WindowsCheckOut.ps1 <server>		
# * Execute the script windows_checkout.ps1  hostname\(filename containing server list)  S\H\SH
####################################################################################################################

# Initialising input paramters $server=server detail and $check (hardware and software) denotes level of checks.
Param(
  [string]$server,
  [string]$check
)
$error.clear()
# If server detail is not given as input,while executing script
if (!$server) 
{
	$server = Read-Host "Enter a Hostname/Name of Server file from script location"
}
# If check detail is not given as input,while executing script
if(!$check)
{
	$check = Read-Host "Enter the check you want , enter H for hardware , S for software and SH for software and hardware"
}
if ($server.endswith(".txt"))
{
# server list
	$servers = Get-Content -path $server
}
elseif($server)
{
	$servers=$server
}
else
{
	write-host "Server Name not given"
	exit 1
}
$a=get-date
##---- Define Variables Uses---------------------------------------------------------------------- 
# $ErrorActionPreference = "SilentlyContinue"
#date format
$date = get-date -format "yyyy-MMM-dd-hhmm"
$script_home="\\firmwide\root\Firmwide\Projects\NY\DivET\GSO_Projects\GSO_Windows_Messaging\SCRIPTS\NonAdmin"
#log level
$log_level=2
#log file creation path
$log_folder="$script_home\Logs"
$log_file="$log_folder\log_$date.txt"
#output file creation
$output_folder="$script_home\output"
$output_file="$output_folder\output_$date.txt"
#$servers="gsfxnmp01as","gsscbdp02ex","gscmstp11exn2","gscmlgp06exn2"
#path for getting powerpath details
$destination="$script_home\tmd.txt"
# Hypervisor user
$user="gsa"
#url for NDS check
$svcInt = "GoldmanSachs.NdsInfraServices.Common.INdsInfraServices"
$svcUri = "https://iws.web.gs.com/ndsinfraservices/soap/service.svc/wssanon"
$iwsLib = "https://iws.web.gs.com/ndsinfraservices/lib/GoldmanSachs.Iws.Common.Client.dll"
$svcLib = "https://iws.web.gs.com/ndsinfraservices/lib/GoldmanSachs.NdsInfraServices.Common.dll"

#-----Define functions----------------------------------------------------------------------------
# 0 - strict ERROR
# 1 - normal INFO
# 2 - debug DEBUG

##Function to write logs
function logMsg($msg_to_log,$msg_type,$logfile="NA") 
{
	if ((!$msg_to_log) -or (!$msg_type)) 
	{
		write-host "Not enough arguments"
	}
	elseif (!($log_level -eq 0 -and $msg_type -ne "ERROR") -and !(($log_level -eq 1) -and ($msg_type -eq "DEBUG"))) 
	{
		$msg_type = $msg_type.PadLeft(8," ")
		$currentDate=get-date
		if ($logfile -eq "NA")
		{
			write-host "$currentDate - $msg_type : $msg_to_log"
		}
		else
		{
			write-output "$currentDate - $msg_type : $msg_to_log" | out-file -Filepath $logfile -append 
		}
	}
}
#function to load  NDS webpage
function loadAssembly()
{  
    param ($assembly)

    $web = new-object System.Net.WebClient
    $assemblyLoaded = [System.Reflection.Assembly]::Load($web.DownloadData($assembly));
    
    return $true
}
#function to connect to dialtone NDS page
function dialTone ($servers)
{
  if (loadAssembly $iwsLib)
  {
    if (loadAssembly $svcLib)
    {
        $channel = [GoldmanSachs.Iws.Common.Client.ChannelFactory].GetMethod("CreateAnonymousChannel")
        $channelGen = $channel.MakeGenericMethod($svcInt)
        $svc = $channelGen.Invoke($null, @($svcUri))
        $svc.RunDialtoneScan($servers)
    }
  }
}
##function to query tidm, appdir and iridium
function queryInventory ($server)
{
	$shortname = $server.split('.')[0]
	#------------- Query Iridium --------------#
	$jsonUrl = "http://iridium.web.gs.com/Server/Xray/General/$($shortname)?api=json"
	$Json=Invoke-RestMethod $jsonUrl -UseDefaultCredentials
	$iridiumObject = ($Json | convertfrom-Json)
	#------------- Query Appdir ---------------#
	$appdirUrl = "http://appdir.web.gs.com/ApplicationDirectory/jQuerySearch.do?method=getHostnames&term=$shortname"
	$FDQN = (Invoke-RestMethod $appdirUrl -UseDefaultCredentials).value
	#------------- Query TIDM -----------------#
	$tidmUrl = "http://rest.prod.tidomain.services.gs.com/tidm/query?query=inventory.PhysicalHost[?(@.hostedOses.displayHostname*==""$server"")]&fields=inventory.PhysicalHost:assetTag,iloaddress,comments,isActive,scanDate,scannedBy,serialNumber&fields=location.GsLocation:displayName&fields=catalog.Product:name&fields=catalog.Category:name&fields=inventory.NetworkAdapter:macAddress&fields=inventory.OsInstance:displayHostname&expand=locations&expand=product&expand=product/categories&expand=networkAdapters&expand=hostedOses&limit=2000"
	$tidmInventoryjson = Invoke-RestMethod $tidmUrl -UseDefaultCredentials
	# $tidmasset="http://rest.prod.tidomain.services.gs.com/tidm/query?query=inventory.OsInstance[?(@.displayHostname*==""$fdqn"")]&expand=deploymentAssets/hostedDeployment/entity/deployment/listAssignments/dlist"

	$tidmasset="http://rest.prod.tidomain.services.gs.com/tidm/query?query=inventory.OsInstance[?(@.displayHostname*==""$server"")]&expand=deploymentAssets/hostedDeployment/entity/deployment/listAssignments/dlist"
	$tidmassetjson = Invoke-RestMethod $tidmasset -UseDefaultCredentials
	#------------- Build Object ---------------#
	$iridiumInfo = new-object -TypeName psobject 
	$iridiumInfo | Add-Member -type NoteProperty -name  "HostName" -value $server
	$iridiumInfo | Add-Member -type NoteProperty -name  "OSType" -value $tidmassetjson.data.osType
	$iridiumInfo | Add-Member -type NoteProperty -name  "OSVersion" -value $tidmassetjson.data.osVersion
	$iridiumInfo | Add-Member -type NoteProperty -name  "Model" -value $iridiumObject.About.Model
	$iridiumInfo | Add-Member -type NoteProperty -name  "Manufacturer" -value $iridiumObject.About.Manufacturer
	$iridiumInfo | Add-Member -type NoteProperty -name  "AssetTag" -value $tidminventoryjson.data.assetTag

	$DIDS=@()
	foreach ($deployment in ($tidmassetjson.data.deploymentassets.data.hosteddeployment.entity.deployment| where {$_.status -ne "DECOMMISSIONED"}))
	{
		$didTemp = New-Object PSObject
		$didTemp | add-member Noteproperty "DeploymentName" $deployment.Deployedname
		$didTemp | add-member Noteproperty "DistributionList" $deployment.listassignments.data.dlist.distributionlistname
		$DIDS += $didTemp
	}
	$iridiumInfo | Add-Member -type NoteProperty -name  "Deployments" -value $DIDS
	return $iridiumInfo
}

## function to get the  password for hypervisor
function getRandomString($assettag)
{ 
	$passphrase = "hyperv@!."
    $salt="AdminSalt"
    $init="Host_Admin"
    
    # Create a COM Object for RijndaelManaged Cryptography
    $r = New-Object System.Security.Cryptography.RijndaelManaged
    # Convert the Passphrase to UTF8 Bytes
    $pass = [Text.Encoding]::UTF8.GetBytes($passphrase)
    # Convert the Salt to UTF Bytes
    $salt = [Text.Encoding]::UTF8.GetBytes($salt)
    
    # Create the Encryption Key using the passphrase, salt and SHA1 algorithm at 256 bits
    $r.Key = (new-Object Security.Cryptography.PasswordDeriveBytes $pass, $salt, "SHA1", 5).GetBytes(32) #256/8
    # Create the Intersecting Vector Cryptology Hash with the init
    $r.IV = (new-Object Security.Cryptography.SHA1Managed).ComputeHash( [Text.Encoding]::UTF8.GetBytes($init) )[0..15]
    
    # Starts the New Encryption using the Key and IV
    $c = $r.CreateEncryptor()
    $ms = New-Object IO.MemoryStream
    $cs = new-Object Security.Cryptography.CryptoStream $ms,$c,"Write"
    $sw = new-Object IO.StreamWriter $cs
    $sw.Write($assettag)
    $sw.Close()
    $cs.Close()
    $ms.Close()
    $r.Clear()
    
    # Takes the MemoryStream and puts it to an array
    [byte[]]$result = $ms.ToArray()
    # Converts the array from Base 64 to a string and returns
    return [Convert]::ToBase64String($result)
}

## function to get VM details for hypervisor machine.
function getVM($server)
{
	if ($server -like 'hv*')
	{
		$hvurl="http://iridium.web.gs.com/Server/Xray/VirtualMachines/$($server.split('.')[0])?api=Json"
		$hvJson=Invoke-RestMethod $hvurl -UseDefaultCredentials
		$vmguests=($hvJson | convertfrom-Json).guests
		$guestobject=@()
		foreach ($guest in $vmguests)
		{
			$temp=$guest.computername
			$vm += $temp
		}
		return $vm
	}	
}	
####------- Functions for EXCHANGE SERVER check-----------------------------------------------------------
#Exchange RPC-request check
function RPC-Request($servers)
{
	try
	{
		$RPCRequests = (Get-Counter "\MSExchangeIS\RPC Requests" -ComputerName $servers  -ErrorAction stop).CounterSamples[0].CookedValue.ToString('N2')
		$output = New-Object PSObject
		$output | Add-member -type NoteProperty -Name "CookedValue" -Value $RPCRequests
		Write-Output $Output
	}
	catch
	{
		$RPCRequests= "NOT OK"
		$output = New-Object PSObject
		$output | Add-member -type NoteProperty -Name "CookedValue" -Value $RPCRequests
		Write-Output $Output
		"Unable to execute the command"|out-file -Filepath $output_file -append 
	}
}
#Exchange RPC-AveragedLatency check
function RPC-AveragedLatency($servers)
{
	try
	{
		$Latency = (Get-Counter "\MSExchangeIS\RPC Averaged Latency" -ComputerName $servers  -ErrorAction stop).CounterSamples[0].CookedValue.ToString('N2')
		$output = New-Object PSObject
		$output | Add-member -type NoteProperty -Name "CookedValue" -Value $Latency
		Write-Output $Output
	}
	catch
	{
		$Latency= "NOT OK"
		$output = New-Object PSObject
		$output | Add-member -type NoteProperty -Name "CookedValue" -Value $Latency
		Write-Output $Output
		"Unable to execute the command"|out-file -Filepath $output_file -append 
	}
}
#Exchange Replay Queue Length check
function ReplayQueueLength($servers,$sg) ##changed input $sg
{
	try
	{
		$ReplayQueueLength = (Get-Counter "\MSExchange Replication($sg)\ReplayQueueLength" -ComputerName $servers  -ErrorAction stop).CounterSamples[0].CookedValue.ToString('N2')
		$output = New-Object PSObject
		$output | Add-member -type NoteProperty -Name "CookedValue" -Value $ReplayQueueLength
		Write-Output $Output
	}
	catch
	{
		$ReplayQueueLength= "NOT OK"
		$output = New-Object PSObject
		$output | Add-member -type NoteProperty -Name "CookedValue" -Value $ReplayQueueLength
		Write-Output $Output
		"Unable to execute the command"|out-file -Filepath $output_file -append 
	}
}
#Exchange Copy Queue Length check
function CopyQueueLength ($servers,$sg) ##changed input $sg
{
	try
	{
		$CopyQueueLength = (Get-Counter "\MSExchange Replication($sg)\CopyQueueLength" -ComputerName $servers  -ErrorAction stop).CounterSamples[0].CookedValue.ToString('N2')
		$output = New-Object PSObject
		$output | Add-member -type NoteProperty -Name "CookedValue" -Value $CopyQueueLength
		Write-Output $Output
	}
	catch
	{
		$CopyQueueLength= "NOT OK"
		$output = New-Object PSObject
		$output | Add-member -type NoteProperty -Name "CookedValue" -Value $CopyQueueLength
		Write-Output $Output
		"Unable to execute the command"|out-file -Filepath $output_file -append 
	}
}
#-----------------------------------------MAIN--------------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------------------------------------
#Check powershell version
if (((get-host).version).Major -lt 3)
{
	write-host "Found Powershell Version:" $host.Version.Major
	Throw  "Script requires Powershell version 3.0 to run, please update to a newer version"
	logMsg "Powershell version is not 3.0" "ERROR" $log_file
	exit 1
}
#Check log folder and If not present create Log folder
If (!(Test-Path $output_folder))
{
	NEW-ITEM $output_folder -type Directory
	logMsg "$output_folder created" "WARN" $log_file
}
#Module to open Excel  and add worksheets
$excel_app = New-Object -Com Excel.Application
$excel_app.visible = $True
$excel = $excel_app.Workbooks.Add()
$excel.worksheets.add()

#Creating an array which consists of the column names in softwarecheck sheet:-
$sheet1 = $excel.WorkSheets.Item(1)
$sheet1.name = "Software_Check"
$sheet1_col=@("Server","PING","Uptime","Drive","Size in GB","Free Space in GB","Percentage Free Space","OS Name","HBA Status","Powerpath Status","NagiosVersion", "RPC_status","IPAddress","Service State","Service Name")
$count=$sheet1_col.length
for($n=1; $n -le $count ; $n++)
{
	$sheet1.Cells.Item(1,$n) = $sheet1_col[($n-1)]
}
$workBook = $sheet1.UsedRange
$workBook.Interior.ColorIndex = 8
$workBook.Font.ColorIndex = 2
$workBook.Font.Bold = $True
$intRow=2

#Creating an array which consists of the column names in hardwarecheck sheet:-
$sheet2 = $excel.WorkSheets.Item(2)
$sheet2.name = "Hardware_Check"
$sheet2_col=@("Server","Version","Disk/Storage check","Power Health Check","Fan Status Check","Memory Status Check","Battery Check")
$count=$sheet2_col.length
for ($n=1; $n -le $count ; $n++)
{
	$sheet2.Cells.Item(1,$n) = $sheet2_col[($n-1)]
}
$workBook = $sheet2.UsedRange
$workBook.Interior.ColorIndex = 8
$workBook.Font.ColorIndex = 2
$workBook.Font.Bold = $True
$intRow1=2

#Creating an array which consists of the column names in exchangecheck sheet:-
$sheet3 = $excel.WorkSheets.Item(3)
$sheet3.name = "Exchange_Check"
$sheet3_col=@("Server","RPC Requests","RPC Averaged Latency","ReplayQueueLength","CopyQueueLength")
$count=$sheet3_col.length
for($n=1; $n -le $count ; $n++)
{
	$sheet3.Cells.Item(1,$n) = $sheet3_col[($n-1)]
}
$workBook = $sheet3.UsedRange
$workBook.Interior.ColorIndex = 8
$workBook.Font.ColorIndex = 2
$workBook.Font.Bold = $True
$int_Row3=2
$intRow3=$int_Row3

#Creating an array which consists of the column names in NDS check sheet:-
$sheet4 = $excel.WorkSheets.Item(4)
$sheet4.name = "NDS_Check"
$sheet4_col=@("DesktopName","Status/IsRunning","Total Size","Free Space","Percentage Free Space")
$count=$sheet4_col.length
for ($n=1; $n -le $count ; $n++)
{
	$sheet4.Cells.Item(1,$n) = $sheet4_col[($n-1)]
}
$workBook = $sheet4.UsedRange
$workBook.Interior.ColorIndex = 8
$workBook.Font.ColorIndex = 2
$workBook.Font.Bold = $True
$intRow4 = 2

foreach($s in $servers)
{
	$system=""
	$s=$s.tolower()
	$tidm_query=queryInventory $s
	$os=$tidm_query.OSType
	write-host " os type: $os"
	$manufacturer=$tidm_query.Manufacturer
	write-host "manufacturer :$manufacturer"
	$assettag=$tidm_query.AssetTag
	write-host " Asset Tag:$assettag"
	$model=$tidm_query.Model
	write-host "Model :$model"
	$deploymentname=$tidm_query.deployments.DeploymentName
	write-host "deploymentname :$deploymentname"
	$distributionlist=$tidm_query.deployments.DistributionList
	if ($deploymentname -match "Exchange")
	{
		$system = "Exchange"
	}
	if ($deploymentname -match "NDS")
	{
		$system = "NDS"
	}

	if($os -match "Hyper-V")
	{
		$vm=getVM ($s)
		$password=getRandomString($assettag)
		$pass_hyper = convertto-securestring "$password" -asplaintext -force
	}
	if (($check -match "S") -or ($check -match ("HS" -or "SH" )) -and ($system -ne "NDS") -and !($os -match "Hyper-V" -or $os -match "ESX"))
	{
	"================================= $s SOFTWARE CHECK =================================================="|Out-File $output_file -append
	$autoservice=$NULL
	$disk_space=$NULL
	"----------------------------------- $s PING CHECK-------------------"|Out-File $output_file -append
	remove-item -path $destination
	#command to check PING
	$ping=Test-Connection -ComputerName $s -Count 1 -ea 0 -quiet
	"Output of Ping test:"|Out-File $output_file -append
	$ping|Out-File $output_file -append
	if(!($ping -eq "True"))
	{
		$sheet1.Cells.Item($intRow,1) = "$s"
		$sheet1.Cells.Item($intRow,2) ="FAILED"
		$intRow= $intRow + 1
		continue
	}
	#Command to get IP
	$ping_output=ping $s
	$ip=$ping_output|select -Last 4|select -First 1
	$ip=$ip.split(" ")[-1].trim(":")

	"----------------------------------- $s DISK SPACE CHECK-------------------"|Out-File $output_file -append
	#command to check the mapped drivers
	$disk_space =  Get-wmiObject -class "Win32_LogicalDisk" -computername $s
	"Output of disk space:"|Out-File $output_file -append
	$disk_space|Out-File $output_file -append
	$disk_space=$disk_space| Where-Object { $_.DeviceID -eq 'C:'}

	#command to get services
	$services= Get-WmiObject Win32_Service -computername $s

	"----------------------------------- $s RPC SERVICE CHECK-------------------"|Out-File $output_file -append
	#command to check RPC service
	$rpc=$services| Where-Object {$_.name -eq "RPCSS"}
	"Output of RPC test:"|Out-File $output_file -append
	$rpc|Out-File $output_file -append

	"----------------------------------- $s AUTO SERVICE CHECK-------------------"|Out-File $output_file -append
	#command to check the Auto service
	$autoservice=$services|Where-Object { $_.StartMode -eq 'Auto'}
	"Output of autoservice:"|Out-File $output_file -append
	$autoservice|Out-File $output_file -append
	$autoservice=$autoservice| Where-Object {$_.State -eq "STOPPED" }

	# To check powerpath
	$powerpath = ([WmiClass]"\\$s\ROOT\CIMV2:Win32_Process").create("cmd /c powermt display > c:\$s-hba.txt")
	#To get Powerpath details for excel
	if ($powerpath.returnvalue -eq 0)
	{
		[diagnostics.process]::start("powershell", "-command & {move-item -path \\$s\c$\$s-hba.txt $destination -force}").waitforexit(10)
	} 

	"----------------------------------- $s UPTIME CHECK-------------------"|Out-File $output_file -append
	#command to check uptime
	$uptime=[Management.ManagementDateTimeConverter]::ToDateTime( (gwmi Win32_OperatingSystem -Comp $s).LastBootUpTime )
	"Output of uptime:"|Out-File $output_file -append
	$uptime|Out-File $output_file -append

	"----------------------------------- $s OS NAME CHECK-------------------"|Out-File $output_file -append
	#command to check OS Name
	$os_name=$os
	"Output of OS name:"|Out-File $output_file -append
	$os_name|Out-File $output_file -append

	#command to check nagios  and routes
	$session= new-pssession -computername $s
	if((Get-PSSession|select computername).computername -ne $s)
	{
		(Get-PSSession|select computername).computername
		logMsg "Unable to connect server: $s" "ERROR"	$log_file
	}
	else
	{
		"----------------------------------- $s NAGIOS CHECK-------------------"|Out-File $output_file -append
		if (test-path "C:\Program Files\*agios*\bin\")
		{
		$nagios_version=Invoke-Command  -session $session -scriptblock { (get-item 'C:\Program Files\*agios*\bin\nagios-agent.exe').VersionInfo.FileVersion }
		}
		else
		{
			write-warning "Path not found for nagios alert" 
		}
	}
	"Output of Nagios version`n:"|Out-File $output_file -append
	$nagios_version|Out-File $output_file -append
	# To remove PSSession for server
	Remove-PSSession $session

	"----------------------------------- $s HBA CHECK-------------------"|Out-File $output_file -append
	# To check INQ
	$hba_info = invoke-command -ComputerName $s {c:\temp\Packages\INQ_1_0\inq -hba }
	$hba_port_status=$hba_info -match "port state"
	$count=$hba_port_status.length
	for($n=0 ; $n -lt $count ;$n++)
	{
		$hba_port_status[$n]=$hba_port_status[$n].split(":",[System.StringSplitOptions]::RemoveEmptyEntries)[1].trim()
	}
	"Output of HBA check `n:"|Out-File $output_file -append
	$hba_info|Out-File $output_file -append

	"----------------------------------- $s POWERPATH CHECK-------------------"|Out-File $output_file -append
	#To get powerpath for excel
	start-sleep -s 10
	$powerpath=get-content $destination
	"Output of POWERPATH check `n:"|Out-File $output_file -append
	$powerpath|Out-File $output_file -append
	$powerpath=$powerpath| select -last 4|select -first 2
	$powerpath_status="OK"
	for($i=0;$i -lt $powerpath.count;$i++)
	{
		$powerpath_data=$powerpath[$i].split(" ",[System.StringSplitOptions]::RemoveEmptyEntries)
		if(($powerpath_data[7] -ne 0) -or ($powerpath_data[4] -ne 0))
		{
		 $powerpath_status="NOT OK"
		 break
		}
	}
	##1.Writing in Excel
	$sheet1.Cells.Item($intRow,1) = "$s"
	$sheet1.Cells.Item($intRow,2) = $ping
	$sheet1.Cells.Item($intRow,3) = $uptime
	$sheet1.Cells.Item($intRow,4) = $disk_space.DeviceID
	$sheet1.Cells.Item($intRow,5) = $disk_space.Size / 1GB
	$sheet1.Cells.Item($intRow,6) = $disk_space.FreeSpace / 1GB
	$sheet1.Cells.Item($intRow,7) = ($disk_space.FreeSpace*100)/($disk_space.Size)
	$sheet1.Cells.Item($intRow,8) = $os_name
	$sheet1.Cells.Item($intRow,10) = $powerpath_status
	$sheet1.Cells.Item($intRow,11)= $nagios_version
	$sheet1.Cells.Item($intRow,12) = $rpc.Status
	$sheet1.Cells.Item($intRow,13) =$ip
	# 6.Excel for writing HBA details
	$count=$hba_port_status.length
	for($n=0 ; $n -lt $count ;$n++)
	{
		if($hba_port_status[$n] -match "ONLINE")
		{
		
			$sheet1.Cells.Item($intRow,9) = "OK"
		}
		else
		{
			$sheet1.Cells.Item($intRow,9) = "NOT OK"
			break
		}
		
	}
	# 2.Excel for writing Auto Service
	$obj_item=" "
	$column=15
	foreach ($obj_item in $autoservice)
	{	
		$sheet1.Cells.Item($intRow,$column) = $obj_item.Name
		$sheet1.Cells.Item($intRow,14) = $obj_item.State
		$column = $column + 1
	}
		$intRow= $intRow + 1
	}
	#Autofit command for worksheet
	$sheet1.columns.autofit()
#To do hardware check
	if (($check -match "H" -or $check -match ("HS" -or "SH")) -and ($model -notmatch "Virtual"))
	{
		"================================= $s HARDWARE CHECK =================================================="|Out-File $output_file -append
		if($manufacturer -match "HP")
		{
			if($os -match "Hyper-V") 
			{
				$cred = new-object -typename System.Management.Automation.PSCredential -argumentlist ($user, $pass_hyper)
				$session = new-PSSession -ComputerName $s -Credential $cred
				$diskStatus_HP = invoke-command -session $session -scriptblock {& "C:\Program Files (x86)\Compaq\Hpacucli\Bin\hpacucli.exe" ctrl all show config}
				#$diskStatus_HP = invoke-command -session $session -scriptblock {& "C:\Program Files (x86)\Compaq\Hpacucli\Bin\hpacucli.exe" controller slot=0 physicaldrive all show status}
				$batteryStatus_HP=invoke-command -session $session -scriptblock {& "C:\Program Files (x86)\Compaq\Hpacucli\Bin\hpacucli.exe" ctrl all show status}
			}
			else
			{
				$session= new-pssession -computername $s
				$diskStatus_HP = invoke-command -session $session -scriptblock {& "C:\Program Files (x86)\Compaq\Hpacucli\Bin\hpacucli.exe" ctrl all show config}
				"----------------------------------- $s DISK CHECK-------------------"|Out-File $output_file -append
				"Output of disk space:"|Out-File $output_file -append
				$diskStatus_HP|Out-File $output_file -append
				$batteryStatus_HP=invoke-command -session $session -scriptblock {& "C:\Program Files (x86)\Compaq\Hpacucli\Bin\hpacucli.exe" ctrl all show status}
				"----------------------------------- $s BATTERY CHECK-------------------"|Out-File $output_file -append
				"Output of Battery Check:"|Out-File $output_file -append
				$batteryStatus_HP|Out-File $output_file -append
			}
			Remove-PSSession $session
			# to get disk status for excel for HP:-
			[str]$disk_status_HP=$diskStatus_HP -match "Fail"
			"Output of disk space:"|Out-File $output_file -append
			$count=$disk_status_HP.length
			for($n=0 ; $n -lt $count ;$n++)
			{
				$disk_status_HP[$n]=($disk_status_HP[$n]).Split(":",[System.StringSplitOptions]::RemoveEmptyEntries)[0]
			}
			$sheet2.Cells.Item($intRow1,1) = $s
			$sheet2.Cells.Item($intRow1,2) = "HP"	
			#to put disk status in excel for hp:-
			$sheet2.Cells.Item($intRow1,3)= "OK"
			for($n=0 ; $n -lt $count ;$n++)
			{
				$sheet2.Cells.Item($intRow1,3)= "NOT OK"
			}
			#to get battery status for excel for HP:-
			[str]$battery_controller_HP=$batteryStatus_HP -match "Controller"
			[str]$battery_capacitor_HP=$batteryStatus_HP -match "Battery"
			[str]$battery_cache_HP=$batteryStatus_HP -match "Cache"
			[str]$battery_name_HP=$batteryStatus_HP -match "^Smart"
			$count=$battery_controller_HP.length
			for($n=0 ; $n -lt $count ;$n++)
			{
				$battery_controller_HP[$n]=($battery_controller_HP[$n]).Split(":",[System.StringSplitOptions]::RemoveEmptyEntries)[1]
				$battery_capacitor_HP[$n]=($battery_capacitor_HP[$n]).Split(":",[System.StringSplitOptions]::RemoveEmptyEntries)[1]
				$battery_cache_HP[$n]=($battery_cache_HP[$n]).Split(":",[System.StringSplitOptions]::RemoveEmptyEntries)[1]
			}
			
			#to put battery status in excel for hp:-
			$count=$battery_controller_HP.length
			for($n=0 ; $n -lt $count ;$n++)
			{
				if (($battery_controller_HP[$n] -notmatch "OK") -or ($battery_cache_HP[$n] -notmatch "OK") -or ($battery_capacitor_HP[$n] -notmatch "OK"))
				{
					$sheet2.Cells.Item($intRow1,7) = "NOT OK"
					break
				}
				else
				{
					$sheet2.Cells.Item($intRow1,7) = "OK"
				}
			}
			$intRow1=$intRow1+1
		}
		# to check DELL hardware
       elseif($manufacturer -match "Dell")
		{	
			if($os -match "Hyper-V")
			{
				$cred = new-object -typename System.Management.Automation.PSCredential -argumentlist ($user, $pass_hyper)
				$session = new-PSSession -ComputerName $s -Credential $cred
				$batteryStatus_D = invoke-command -Session $session -scriptblock {& "C:\Program Files (x86)\Dell\SysMgt\oma\bin\omreport.exe" storage battery}
				"----------------------------------- $s BATTERY CHECK-------------------"|Out-File $output_file -append
				"Output of battery status:"|Out-File $output_file -append
				$batteryStatus_D|Out-File $output_file -append
				$storagedisk_D= invoke-command -Session $session -scriptblock {& "C:\Program Files (x86)\Dell\SysMgt\oma\bin\omreport.exe" storage vdisk}
				"----------------------------------- $s STORAGE CHECK-------------------"|Out-File $output_file -append
				"Output of storage disk:"|Out-File $output_file -append
				$storagedisk_D|Out-File $output_file -append
				$powerhealthstatus_D= invoke-command -Session $session -scriptblock {& "C:\Program Files (x86)\Dell\SysMgt\oma\bin\omreport.exe" chassis pwrsupplies}
				"----------------------------------- $s POWER HEALTH CHECK-------------------"|Out-File $output_file -append
				"Output of power health status:"|Out-File $output_file -append
				$powerhealthstatus_D|Out-File $output_file -append
				$ph_redundantstatus_D=$powerhealthstatus_D  -match "^Redundancy Status"
				$ph_mainstatus_D="0K"
				$fanstatus_D=invoke-command -Session $session -scriptblock {& "C:\Program Files (x86)\Dell\SysMgt\oma\bin\omreport.exe" chassis fans }
				"----------------------------------- $s FAN STATUS CHECK-------------------"|Out-File $output_file -append
				"Output of fan status:"|Out-File $output_file -append
				$fanstatus_D|Out-File $output_file -append
				$fan_redundantstatus_D=$fanstatus_D -match "^Redundancy Status"
				$fan_mainstatus_D="OK"
				$memorystatus_D=invoke-command -Session $session -scriptblock {& "C:\Program Files (x86)\Dell\SysMgt\oma\bin\omreport.exe" chassis memory}
				"----------------------------------- $s MEMORY CHECK-------------------"|Out-File $output_file -append
				"Output of memory status:"|Out-File $output_file -append
				$memorystatus_D|Out-File $output_file -append
			}	
			else
			{
				$session = new-pssession -computername $s
				$batteryStatus_D = invoke-command -Session $session -scriptblock {& "C:\Program Files (x86)\Dell\SysMgt\oma\bin\omreport.exe" storage battery}
				"----------------------------------- $s BATTERY CHECK-------------------"|Out-File $output_file -append
				"Output of battery status:"|Out-File $output_file -append
				$batteryStatus_D|Out-File $output_file -append
				$batteryStatus_D
				$storagedisk_D= invoke-command -Session $session -scriptblock {& "C:\Program Files (x86)\Dell\SysMgt\oma\bin\omreport.exe" storage vdisk}
				"----------------------------------- $s STORAGE CHECK-------------------"|Out-File $output_file -append
				"Output of storage disk:"|Out-File $output_file -append
				$storagedisk_D|Out-File $output_file -append
				$storagedisk_D
				$powerhealthstatus_D= invoke-command -Session $session -scriptblock {& "C:\Program Files (x86)\Dell\SysMgt\oma\bin\omreport.exe" chassis pwrsupplies}
				"----------------------------------- $s POWER HEALTH CHECK-------------------"|Out-File $output_file -append
				"Output of power health status:"|Out-File $output_file -append
				$powerhealthstatus_D|Out-File $output_file -append
				$ph_mainstatus_D=$powerhealthstatus_D  -match "^Main System"
				$ph_redundantstatus_D=$powerhealthstatus_D  -match "^Power Supply Redundancy"
				$ph_mainstatus_D=$ph_mainstatus_D.Split(":",[System.StringSplitOptions]::RemoveEmptyEntries)[1]
				$fanstatus_D=invoke-command -Session $session -scriptblock {& "C:\Program Files (x86)\Dell\SysMgt\oma\bin\omreport.exe" chassis fans }
				"----------------------------------- $s FAN STATUS CHECK-------------------"|Out-File $output_file -append
				"Output of fan status:"|Out-File $output_file -append
				$fanstatus_D|Out-File $output_file -append
				$fan_redundantstatus_D=$fanstatus_D -match "^Fan Redundancy"
				$fan_mainstatus_D=$fanstatus_D -match "^Main System"
				$fan_mainstatus_D=$fan_mainstatus_D.Split(":",[System.StringSplitOptions]::RemoveEmptyEntries)[1]
				$memorystatus_D=invoke-command -Session $session -scriptblock {& "C:\Program Files (x86)\Dell\SysMgt\oma\bin\omreport.exe" chassis memory}
				"----------------------------------- $s MEMORY CHECK-------------------"|Out-File $output_file -append
				"Output of memory status:"|Out-File $output_file -append
				$memorystatus_D|Out-File $output_file -append
			}
			Remove-PSSession $session
			
			
			##to get battery status for excel for Dell:-	
			$battery_status_D=$batteryStatus_D -match "^Status"
			$count=$battery_status_D.length
			for($n=0 ; $n -lt $count ;$n++)
			{
			$battery_status_D[$n]=($battery_status_D[$n]).Split(":",[System.StringSplitOptions]::RemoveEmptyEntries)[1]
			}
			# # to get storage disk for excel:-
			$storage_status_D=$storagedisk_D -match "^Status"
			$count=$storage_status_D.length
			for($n=0 ; $n -lt $count ; $n++)
			{
			$storage_status_D[$n]=($storage_status_D[$n]).Split(":",[System.StringSplitOptions]::RemoveEmptyEntries)[1]
			}
			##to get powerhealth status for excel:-
			$ph_status_D=$powerhealthstatus_D -match "^Status"
			$count=$ph_status_D.length
			$ph_redundantstatus_D=$ph_redundantstatus_D.Split(":",[System.StringSplitOptions]::RemoveEmptyEntries)[1]		
			for($n=0 ; $n -lt $count ; $n++)
			{
				$ph_status_D[$n]=($ph_status_D[$n]).Split(":",[System.StringSplitOptions]::RemoveEmptyEntries)[1]
			}
			
			# to get fan status for excel:-
			$fan_status_D=$fanstatus_D -match "^Status"
			$fan_redundantstatus_D=$fan_redundantstatus_D.Split(":",[System.StringSplitOptions]::RemoveEmptyEntries)[1]
			$count=$fan_status_D.length
			for($n=0 ; $n -lt $count ; $n++)
			{
			$fan_status_D[$n]=($fan_status_D[$n]).Split(":",[System.StringSplitOptions]::RemoveEmptyEntries)[1]
			}
			# to get memory status for excel:-		
			$memory_mainstatus_D=$memorystatus_D -match "^Health"
			$memory_status_D=$memorystatus_D -match "^Status"
			$memory_mainstatus_D=$memory_mainstatus_D.Split(":",[System.StringSplitOptions]::RemoveEmptyEntries)[1]
			$count=$memory_status_D.length
			for ($n=0 ;$n -lt $count ; $n++)
			{
			$memory_status_D[$n]=($memory_status_D[$n]).Split(":",[System.StringSplitOptions]::RemoveEmptyEntries)[1]
			}
			$sheet2.Cells.Item($intRow1,1) = "$s"
			$sheet2.Cells.Item($intRow1,2) = "DELL"
			# to put storage disk status in excel:-	
			$count=$storage_status_D.length
			for($n=0 ; $n -lt $count ; $n++)
			{
				if((($storage_status_D[$n] -match "Degraded") -or ($storage_status_D[$n] -match "Critical")) -and ($storage_status_D[$n] -notmatch "Non-Critical"))
				{
					$sheet2.Cells.Item($intRow1,3) ="NOT OK"
					break
				}
				else
				{
					$sheet2.Cells.Item($intRow1,3) ="OK"
				}
			}
			# to put battery status in excel:-	
			$count=$battery_status_D.length
			for($n=0 ; $n -lt $count ; $n++)
			{$battery_status_D[$n]
				if (!($battery_status_D[$n] -match "OK"))
				{
					$sheet2.Cells.Item($intRow1,7) = "NOT OK"
					break
				}
				else
				{
					$sheet2.Cells.Item($intRow1,7) ="OK"
				}
			}
			# to put powerhealth status in excel:-
			$count=$ph_status_D.length
			for($n=0 ; $n -lt $count ; $n++)
			{$ph_status_D[$n]
				if (!($ph_status_D[$n] -match "Ok"))
				{
					$sheet2.Cells.Item($intRow1,4) = "NOT OK"
					$power_status="NOT OK"
					break
				}
				else
				{
					$sheet2.Cells.Item($intRow1,4) = "OK"
					$power_status="OK"
					
				}
			}
			if($power_status -eq "OK")
			{
				$sheet2.Cells.Item($intRow1,4) = $ph_mainstatus_D
				$sheet2.Cells.Item($intRow1,4) = $ph_redundantstatus_D
			}
			# to put fanstatus in excel:-
			$count=$fan_status_D.length
			for($n=0 ; $n -lt $count ; $n++)
			{$fan_status_D[$n]
				if(!($fan_status_D[$n] -match "Ok"))
				{
					$sheet2.Cells.Item($intRow1,5) = "NOT OK"
					$fan_status="NOT OK"
					break
				}
				else
				{
					$sheet2.Cells.Item($intRow1,5) = "OK"
					$fan_status="OK"
				}
			}
			if($fan_status -eq "OK")
			{
				$sheet2.Cells.Item($intRow1,5) = $fan_mainstatus_D
				$sheet2.Cells.Item($intRow1,5) = $fan_redundantstatus_D
			}
			# to put memorystatus in excel
			$count=$memory_status_D.length
			for ($n=0 ;$n -lt $count ; $n++)
			{
				$memory_status_D[$n]
				if(($memory_status_D[$n] -notmatch "Ok") -and ($memory_status_D[$n] -notmatch "Unknown"))
				{
					$sheet2.Cells.Item($intRow1,6) = "NOT OK"
					$memory_status="NOT OK"
					break
				}
				else
				{
					$sheet2.Cells.Item($intRow1,6) = "OK"
					$memory_status="OK"
				}
			}
			if($memory_status -eq "OK")
			{
				$sheet2.Cells.Item($intRow1,6)=$memory_mainstatus_D
			}
			$sheet2.columns.autofit()
			$intRow1=$intRow1+1
		}
		else
		{
			write-host "SERVER is neither HP nor DELL"
		}
	}
	if(($check -match "S") -and ($system -eq "Exchange"))
	{
		"================================= $s EXCHANGE CHECK =================================================="|Out-File $output_file -append
		$sg="_Total"
		"----------------------------------- $s RPC CHECK-------------------"|Out-File $output_file -append
		"Output of Exchange RPC-Request:"|Out-File $output_file -append
		$RPC= 1..5 | Foreach-Object {
			RPC-Request $s
			Start-Sleep -Seconds 1
		}
		$RPC|Out-File $output_file -append
		"----------------------------------- $s RPC AveragedLatency CHECK-------------------"|Out-File $output_file -append
		"Output of Exchange RPC-AveragedLatency:"|Out-File $output_file -append
		$RPC_AveragedLatency= 1..5 | Foreach-Object {
			RPC-AveragedLatency $s
			Start-Sleep -Seconds 1
		}
		$RPC_AveragedLatency|Out-File $output_file -append
		# calling Exchange check function
		"----------------------------------- $s Replay Queue Length-------------------"|Out-File $output_file -append
		"Output of Exchange Replay Queue Length:"|Out-File $output_file -append
		$ReplayQueueLength= 1..5 | Foreach-Object {
			ReplayQueueLength  $s $sg
			Start-Sleep -Seconds 1
		}
		$ReplayQueueLength|Out-File $output_file -append
		"----------------------------------- $s Copy Queue Length-------------------"|Out-File $output_file -append
		"Output of Exchange Copy Queue Length:"|Out-File $output_file -append
		$CopyQueueLength= 1..5 | Foreach-Object{
			CopyQueueLength  $s $sg
			Start-Sleep -Seconds 1
		}
		$CopyQueueLength|Out-File $output_file -append
		foreach ($obj_item in $RPC) 
		{
			$sheet3.Cells.Item($intRow3,1) = $s
			$sheet3.Cells.Item($intRow3,2) = $obj_item.CookedValue
			$intRow3 = $intRow3 + 1
		}
		$intRow3=$int_row3
		foreach ($obj_item in $RPC_AveragedLatency) 
		{
			$sheet3.Cells.Item($intRow3,3) = $obj_item.CookedValue
			$intRow3 = $intRow3 + 1
		}
		$intRow3=$int_row3
		foreach ($obj_item in $ReplayQueueLength) 
		{
			$sheet3.Cells.Item($intRow3,4) = $obj_item.CookedValue
			$intRow3 = $intRow3 + 1
		}
		$intRow3=$int_row3
		foreach ($obj_item in $CopyQueueLength) 
		{
			$sheet3.Cells.Item($intRow3,5) = $obj_item.CookedValue
			$intRow3 = $intRow3 + 1
		}
		$int_row3=$int_row3+5
		$sheet3.columns.autofit()
	}
	##---------- Check if Software check and the machine is NDS------------------------------
	if($check -match "S" -and $system -match "NDS")
	{
		"================================= $s NDS CHECK =================================================="|Out-File $output_file -append
		$total_space=0
		$free_space=0
		$upstatus=$NULL
		$nds_check=dialTone ($s)
		"Dialtone output"|Out-File $output_file -append
		$nds_check|Out-File $output_file -append
		$disk_space =  Get-wmiObject -class "Win32_LogicalDisk" -computername $s
		$disk_space=$disk_space| Where-Object { $_.DeviceID -eq 'C:'}
		$total_space=$disk_space.Size/1GB
		$free_space=$disk_space.FreeSpace/1GB
		# To check status of service which are not running 
		if (($nds_check.IsRunning -match "False") -or ($nds_check.IsRunning -eq $NULL))
		{
			$upstatus="FAIL"
		}
		if ($upstatus -eq $NULL)
		{
				$sheet4.Cells.Item($intRow4,1) = $s
				$sheet4.Cells.Item($intRow4,2) = "OK"
		}
		else
		{
			$sheet4.Cells.Item($intRow4,1) = $s
			$sheet4.Cells.Item($intRow4,2) = "NOT OK"
		}
		$sheet4.Cells.Item($intRow4,3) = $total_space
		$sheet4.Cells.Item($intRow4,4) = $free_space
		if($free_space -ne 0)
		{
			$sheet4.Cells.Item($intRow4,5) = ($free_space*100)/$total_space
		}
		$intRow4 = $intRow4 + 1
	$sheet4.columns.autofit()
	}
}
$b=get-date
$a-$b
